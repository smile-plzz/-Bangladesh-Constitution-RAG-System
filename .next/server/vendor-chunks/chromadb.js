"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chromadb";
exports.ids = ["vendor-chunks/chromadb"];
exports.modules = {

/***/ "(rsc)/./node_modules/chromadb/dist/chromadb.mjs":
/*!*************************************************!*\
  !*** ./node_modules/chromadb/dist/chromadb.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdminClient: () => (/* binding */ AdminClient),\n/* harmony export */   AdminCloudClient: () => (/* binding */ AdminCloudClient),\n/* harmony export */   ChromaClient: () => (/* binding */ ChromaClient),\n/* harmony export */   ChromaClientError: () => (/* binding */ ChromaClientError),\n/* harmony export */   ChromaConnectionError: () => (/* binding */ ChromaConnectionError),\n/* harmony export */   ChromaError: () => (/* binding */ ChromaError),\n/* harmony export */   ChromaForbiddenError: () => (/* binding */ ChromaForbiddenError),\n/* harmony export */   ChromaNotFoundError: () => (/* binding */ ChromaNotFoundError),\n/* harmony export */   ChromaQuotaExceededError: () => (/* binding */ ChromaQuotaExceededError),\n/* harmony export */   ChromaRateLimitError: () => (/* binding */ ChromaRateLimitError),\n/* harmony export */   ChromaServerError: () => (/* binding */ ChromaServerError),\n/* harmony export */   ChromaUnauthorizedError: () => (/* binding */ ChromaUnauthorizedError),\n/* harmony export */   ChromaUniqueError: () => (/* binding */ ChromaUniqueError),\n/* harmony export */   ChromaValueError: () => (/* binding */ ChromaValueError),\n/* harmony export */   CloudClient: () => (/* binding */ CloudClient),\n/* harmony export */   GetResult: () => (/* binding */ GetResult),\n/* harmony export */   IncludeEnum: () => (/* binding */ IncludeEnum),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidCollectionError: () => (/* binding */ InvalidCollectionError),\n/* harmony export */   QueryResult: () => (/* binding */ QueryResult),\n/* harmony export */   baseRecordSetFields: () => (/* binding */ baseRecordSetFields),\n/* harmony export */   createErrorByType: () => (/* binding */ createErrorByType),\n/* harmony export */   getDefaultEFConfig: () => (/* binding */ getDefaultEFConfig),\n/* harmony export */   getEmbeddingFunction: () => (/* binding */ getEmbeddingFunction),\n/* harmony export */   knownEmbeddingFunctions: () => (/* binding */ knownEmbeddingFunctions),\n/* harmony export */   processCreateCollectionConfig: () => (/* binding */ processCreateCollectionConfig),\n/* harmony export */   processUpdateCollectionConfig: () => (/* binding */ processUpdateCollectionConfig),\n/* harmony export */   recordSetFields: () => (/* binding */ recordSetFields),\n/* harmony export */   registerEmbeddingFunction: () => (/* binding */ registerEmbeddingFunction),\n/* harmony export */   serializeEmbeddingFunction: () => (/* binding */ serializeEmbeddingFunction),\n/* harmony export */   withChroma: () => (/* binding */ withChroma)\n/* harmony export */ });\n/* harmony import */ var _chunk_NSSMTXJJ_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-NSSMTXJJ.mjs */ \"(rsc)/./node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs\");\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:process */ \"node:process\");\n\n\n// src/deno.ts\nif (typeof globalThis.Deno !== \"undefined\") {\n  const OriginalRequest = globalThis.Request;\n  const PatchedRequest = function(input, init) {\n    if (init && typeof init === \"object\") {\n      const cleanInit = { ...init };\n      if (\"client\" in cleanInit) {\n        delete cleanInit.client;\n      }\n      return new OriginalRequest(input, cleanInit);\n    }\n    return new OriginalRequest(input, init);\n  };\n  Object.setPrototypeOf(PatchedRequest, OriginalRequest);\n  Object.defineProperty(PatchedRequest, \"prototype\", {\n    value: OriginalRequest.prototype,\n    writable: false\n  });\n  globalThis.Request = PatchedRequest;\n}\n\n// src/types.ts\nvar baseRecordSetFields = [\n  \"ids\",\n  \"embeddings\",\n  \"metadatas\",\n  \"documents\",\n  \"uris\"\n];\nvar recordSetFields = [...baseRecordSetFields, \"ids\"];\nvar IncludeEnum = /* @__PURE__ */ ((IncludeEnum2) => {\n  IncludeEnum2[\"distances\"] = \"distances\";\n  IncludeEnum2[\"documents\"] = \"documents\";\n  IncludeEnum2[\"embeddings\"] = \"embeddings\";\n  IncludeEnum2[\"metadatas\"] = \"metadatas\";\n  IncludeEnum2[\"uris\"] = \"uris\";\n  return IncludeEnum2;\n})(IncludeEnum || {});\nvar GetResult = class {\n  /**\n   * Creates a new GetResult instance.\n   * @param data - The result data containing all fields\n   */\n  constructor({\n    documents,\n    embeddings,\n    ids,\n    include,\n    metadatas,\n    uris\n  }) {\n    this.documents = documents;\n    this.embeddings = embeddings;\n    this.ids = ids;\n    this.include = include;\n    this.metadatas = metadatas;\n    this.uris = uris;\n  }\n  /**\n   * Converts the result to a row-based format for easier iteration.\n   * @returns Object containing include fields and array of record objects\n   */\n  rows() {\n    return this.ids.map((id, index) => {\n      return {\n        id,\n        document: this.include.includes(\"documents\") ? this.documents[index] : void 0,\n        embedding: this.include.includes(\"embeddings\") ? this.embeddings[index] : void 0,\n        metadata: this.include.includes(\"metadatas\") ? this.metadatas[index] : void 0,\n        uri: this.include.includes(\"uris\") ? this.uris[index] : void 0\n      };\n    });\n  }\n};\nvar QueryResult = class {\n  /**\n   * Creates a new QueryResult instance.\n   * @param data - The query result data containing all fields\n   */\n  constructor({\n    distances,\n    documents,\n    embeddings,\n    ids,\n    include,\n    metadatas,\n    uris\n  }) {\n    this.distances = distances;\n    this.documents = documents;\n    this.embeddings = embeddings;\n    this.ids = ids;\n    this.include = include;\n    this.metadatas = metadatas;\n    this.uris = uris;\n  }\n  /**\n   * Converts the query result to a row-based format for easier iteration.\n   * @returns Object containing include fields and structured query results\n   */\n  rows() {\n    const queries = [];\n    for (let q2 = 0; q2 < this.ids.length; q2++) {\n      const records = this.ids[q2].map((id, index) => {\n        return {\n          id,\n          document: this.include.includes(\"documents\") ? this.documents[q2][index] : void 0,\n          embedding: this.include.includes(\"embeddings\") ? this.embeddings[q2][index] : void 0,\n          metadata: this.include.includes(\"metadatas\") ? this.metadatas[q2][index] : void 0,\n          uri: this.include.includes(\"uris\") ? this.uris[q2][index] : void 0,\n          distance: this.include.includes(\"distances\") ? this.distances[q2][index] : void 0\n        };\n      });\n      queries.push(records);\n    }\n    return queries;\n  }\n};\n\n// ../../node_modules/.pnpm/@hey-api+client-fetch@0.10.0_@hey-api+openapi-ts@0.67.3_typescript@5.8.3_/node_modules/@hey-api/client-fetch/dist/index.js\nvar A = async (t, r) => {\n  let e = typeof r == \"function\" ? await r(t) : r;\n  if (e) return t.scheme === \"bearer\" ? `Bearer ${e}` : t.scheme === \"basic\" ? `Basic ${btoa(e)}` : e;\n};\nvar R = { bodySerializer: (t) => JSON.stringify(t, (r, e) => typeof e == \"bigint\" ? e.toString() : e) };\nvar U = (t) => {\n  switch (t) {\n    case \"label\":\n      return \".\";\n    case \"matrix\":\n      return \";\";\n    case \"simple\":\n      return \",\";\n    default:\n      return \"&\";\n  }\n};\nvar _ = (t) => {\n  switch (t) {\n    case \"form\":\n      return \",\";\n    case \"pipeDelimited\":\n      return \"|\";\n    case \"spaceDelimited\":\n      return \"%20\";\n    default:\n      return \",\";\n  }\n};\nvar D = (t) => {\n  switch (t) {\n    case \"label\":\n      return \".\";\n    case \"matrix\":\n      return \";\";\n    case \"simple\":\n      return \",\";\n    default:\n      return \"&\";\n  }\n};\nvar O = ({ allowReserved: t, explode: r, name: e, style: a, value: i }) => {\n  if (!r) {\n    let s = (t ? i : i.map((l) => encodeURIComponent(l))).join(_(a));\n    switch (a) {\n      case \"label\":\n        return `.${s}`;\n      case \"matrix\":\n        return `;${e}=${s}`;\n      case \"simple\":\n        return s;\n      default:\n        return `${e}=${s}`;\n    }\n  }\n  let o = U(a), n = i.map((s) => a === \"label\" || a === \"simple\" ? t ? s : encodeURIComponent(s) : y({ allowReserved: t, name: e, value: s })).join(o);\n  return a === \"label\" || a === \"matrix\" ? o + n : n;\n};\nvar y = ({ allowReserved: t, name: r, value: e }) => {\n  if (e == null) return \"\";\n  if (typeof e == \"object\") throw new Error(\"Deeply-nested arrays/objects aren\\u2019t supported. Provide your own `querySerializer()` to handle these.\");\n  return `${r}=${t ? e : encodeURIComponent(e)}`;\n};\nvar q = ({ allowReserved: t, explode: r, name: e, style: a, value: i }) => {\n  if (i instanceof Date) return `${e}=${i.toISOString()}`;\n  if (a !== \"deepObject\" && !r) {\n    let s = [];\n    Object.entries(i).forEach(([f, u]) => {\n      s = [...s, f, t ? u : encodeURIComponent(u)];\n    });\n    let l = s.join(\",\");\n    switch (a) {\n      case \"form\":\n        return `${e}=${l}`;\n      case \"label\":\n        return `.${l}`;\n      case \"matrix\":\n        return `;${e}=${l}`;\n      default:\n        return l;\n    }\n  }\n  let o = D(a), n = Object.entries(i).map(([s, l]) => y({ allowReserved: t, name: a === \"deepObject\" ? `${e}[${s}]` : s, value: l })).join(o);\n  return a === \"label\" || a === \"matrix\" ? o + n : n;\n};\nvar H = /\\{[^{}]+\\}/g;\nvar B = ({ path: t, url: r }) => {\n  let e = r, a = r.match(H);\n  if (a) for (let i of a) {\n    let o = false, n = i.substring(1, i.length - 1), s = \"simple\";\n    n.endsWith(\"*\") && (o = true, n = n.substring(0, n.length - 1)), n.startsWith(\".\") ? (n = n.substring(1), s = \"label\") : n.startsWith(\";\") && (n = n.substring(1), s = \"matrix\");\n    let l = t[n];\n    if (l == null) continue;\n    if (Array.isArray(l)) {\n      e = e.replace(i, O({ explode: o, name: n, style: s, value: l }));\n      continue;\n    }\n    if (typeof l == \"object\") {\n      e = e.replace(i, q({ explode: o, name: n, style: s, value: l }));\n      continue;\n    }\n    if (s === \"matrix\") {\n      e = e.replace(i, `;${y({ name: n, value: l })}`);\n      continue;\n    }\n    let f = encodeURIComponent(s === \"label\" ? `.${l}` : l);\n    e = e.replace(i, f);\n  }\n  return e;\n};\nvar E = ({ allowReserved: t, array: r, object: e } = {}) => (i) => {\n  let o = [];\n  if (i && typeof i == \"object\") for (let n in i) {\n    let s = i[n];\n    if (s != null) {\n      if (Array.isArray(s)) {\n        o = [...o, O({ allowReserved: t, explode: true, name: n, style: \"form\", value: s, ...r })];\n        continue;\n      }\n      if (typeof s == \"object\") {\n        o = [...o, q({ allowReserved: t, explode: true, name: n, style: \"deepObject\", value: s, ...e })];\n        continue;\n      }\n      o = [...o, y({ allowReserved: t, name: n, value: s })];\n    }\n  }\n  return o.join(\"&\");\n};\nvar P = (t) => {\n  if (!t) return \"stream\";\n  let r = t.split(\";\")[0]?.trim();\n  if (r) {\n    if (r.startsWith(\"application/json\") || r.endsWith(\"+json\")) return \"json\";\n    if (r === \"multipart/form-data\") return \"formData\";\n    if ([\"application/\", \"audio/\", \"image/\", \"video/\"].some((e) => r.startsWith(e))) return \"blob\";\n    if (r.startsWith(\"text/\")) return \"text\";\n  }\n};\nvar I = async ({ security: t, ...r }) => {\n  for (let e of t) {\n    let a = await A(e, r.auth);\n    if (!a) continue;\n    let i = e.name ?? \"Authorization\";\n    switch (e.in) {\n      case \"query\":\n        r.query || (r.query = {}), r.query[i] = a;\n        break;\n      case \"cookie\":\n        r.headers.append(\"Cookie\", `${i}=${a}`);\n        break;\n      case \"header\":\n      default:\n        r.headers.set(i, a);\n        break;\n    }\n    return;\n  }\n};\nvar S = (t) => W({ baseUrl: t.baseUrl, path: t.path, query: t.query, querySerializer: typeof t.querySerializer == \"function\" ? t.querySerializer : E(t.querySerializer), url: t.url });\nvar W = ({ baseUrl: t, path: r, query: e, querySerializer: a, url: i }) => {\n  let o = i.startsWith(\"/\") ? i : `/${i}`, n = (t ?? \"\") + o;\n  r && (n = B({ path: r, url: n }));\n  let s = e ? a(e) : \"\";\n  return s.startsWith(\"?\") && (s = s.substring(1)), s && (n += `?${s}`), n;\n};\nvar C = (t, r) => {\n  let e = { ...t, ...r };\n  return e.baseUrl?.endsWith(\"/\") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = x(t.headers, r.headers), e;\n};\nvar x = (...t) => {\n  let r = new Headers();\n  for (let e of t) {\n    if (!e || typeof e != \"object\") continue;\n    let a = e instanceof Headers ? e.entries() : Object.entries(e);\n    for (let [i, o] of a) if (o === null) r.delete(i);\n    else if (Array.isArray(o)) for (let n of o) r.append(i, n);\n    else o !== void 0 && r.set(i, typeof o == \"object\" ? JSON.stringify(o) : o);\n  }\n  return r;\n};\nvar h = class {\n  constructor() {\n    (0,_chunk_NSSMTXJJ_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"_fns\");\n    this._fns = [];\n  }\n  clear() {\n    this._fns = [];\n  }\n  exists(r) {\n    return this._fns.indexOf(r) !== -1;\n  }\n  eject(r) {\n    let e = this._fns.indexOf(r);\n    e !== -1 && (this._fns = [...this._fns.slice(0, e), ...this._fns.slice(e + 1)]);\n  }\n  use(r) {\n    this._fns = [...this._fns, r];\n  }\n};\nvar T = () => ({ error: new h(), request: new h(), response: new h() });\nvar N = E({ allowReserved: false, array: { explode: true, style: \"form\" }, object: { explode: true, style: \"deepObject\" } });\nvar Q = { \"Content-Type\": \"application/json\" };\nvar w = (t = {}) => ({ ...R, headers: Q, parseAs: \"auto\", querySerializer: N, ...t });\nvar J = (t = {}) => {\n  let r = C(w(), t), e = () => ({ ...r }), a = (n) => (r = C(r, n), e()), i = T(), o = async (n) => {\n    let s = { ...r, ...n, fetch: n.fetch ?? r.fetch ?? globalThis.fetch, headers: x(r.headers, n.headers) };\n    s.security && await I({ ...s, security: s.security }), s.body && s.bodySerializer && (s.body = s.bodySerializer(s.body)), (s.body === void 0 || s.body === \"\") && s.headers.delete(\"Content-Type\");\n    let l = S(s), f = { redirect: \"follow\", ...s }, u = new Request(l, f);\n    for (let p of i.request._fns) u = await p(u, s);\n    let k = s.fetch, c = await k(u);\n    for (let p of i.response._fns) c = await p(c, u, s);\n    let m = { request: u, response: c };\n    if (c.ok) {\n      if (c.status === 204 || c.headers.get(\"Content-Length\") === \"0\") return { data: {}, ...m };\n      let p = (s.parseAs === \"auto\" ? P(c.headers.get(\"Content-Type\")) : s.parseAs) ?? \"json\";\n      if (p === \"stream\") return { data: c.body, ...m };\n      let b = await c[p]();\n      return p === \"json\" && (s.responseValidator && await s.responseValidator(b), s.responseTransformer && (b = await s.responseTransformer(b))), { data: b, ...m };\n    }\n    let g = await c.text();\n    try {\n      g = JSON.parse(g);\n    } catch {\n    }\n    let d = g;\n    for (let p of i.error._fns) d = await p(g, c, u, s);\n    if (d = d || {}, s.throwOnError) throw d;\n    return { error: d, ...m };\n  };\n  return { buildUrl: S, connect: (n) => o({ ...n, method: \"CONNECT\" }), delete: (n) => o({ ...n, method: \"DELETE\" }), get: (n) => o({ ...n, method: \"GET\" }), getConfig: e, head: (n) => o({ ...n, method: \"HEAD\" }), interceptors: i, options: (n) => o({ ...n, method: \"OPTIONS\" }), patch: (n) => o({ ...n, method: \"PATCH\" }), post: (n) => o({ ...n, method: \"POST\" }), put: (n) => o({ ...n, method: \"PUT\" }), request: o, setConfig: a, trace: (n) => o({ ...n, method: \"TRACE\" }) };\n};\n\n// src/api/client.gen.ts\nvar client = J(w({\n  baseUrl: \"http://localhost:8000\",\n  throwOnError: true\n}));\n\n// src/api/sdk.gen.ts\nvar DefaultService = class {\n  /**\n   * Retrieves the current user's identity, tenant, and databases.\n   */\n  static getUserIdentity(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/auth/identity\",\n      ...options\n    });\n  }\n  /**\n   * Health check endpoint that returns 200 if the server and executor are ready\n   */\n  static healthcheck(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/healthcheck\",\n      ...options\n    });\n  }\n  /**\n   * Heartbeat endpoint that returns a nanosecond timestamp of the current time.\n   */\n  static heartbeat(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/heartbeat\",\n      ...options\n    });\n  }\n  /**\n   * Pre-flight checks endpoint reporting basic readiness info.\n   */\n  static preFlightChecks(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/pre-flight-checks\",\n      ...options\n    });\n  }\n  /**\n   * Reset endpoint allowing authorized users to reset the database.\n   */\n  static reset(options) {\n    return (options?.client ?? client).post({\n      url: \"/api/v2/reset\",\n      ...options\n    });\n  }\n  /**\n   * Creates a new tenant.\n   */\n  static createTenant(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Returns an existing tenant by name.\n   */\n  static getTenant(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant_name}\",\n      ...options\n    });\n  }\n  /**\n   * Updates an existing tenant by name.\n   */\n  static updateTenant(options) {\n    return (options.client ?? client).patch({\n      url: \"/api/v2/tenants/{tenant_name}\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Lists all databases for a given tenant.\n   */\n  static listDatabases(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases\",\n      ...options\n    });\n  }\n  /**\n   * Creates a new database for a given tenant.\n   */\n  static createDatabase(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Deletes a specific database.\n   */\n  static deleteDatabase(options) {\n    return (options.client ?? client).delete({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}\",\n      ...options\n    });\n  }\n  /**\n   * Retrieves a specific database by name.\n   */\n  static getDatabase(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}\",\n      ...options\n    });\n  }\n  /**\n   * Lists all collections in the specified database.\n   */\n  static listCollections(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections\",\n      ...options\n    });\n  }\n  /**\n   * Creates a new collection under the specified database.\n   */\n  static createCollection(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Deletes a collection in a given database.\n   */\n  static deleteCollection(options) {\n    return (options.client ?? client).delete({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}\",\n      ...options\n    });\n  }\n  /**\n   * Retrieves a collection by ID or name.\n   */\n  static getCollection(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}\",\n      ...options\n    });\n  }\n  /**\n   * Updates an existing collection's name or metadata.\n   */\n  static updateCollection(options) {\n    return (options.client ?? client).put({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Adds records to a collection.\n   */\n  static collectionAdd(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/add\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Retrieves the number of records in a collection.\n   */\n  static collectionCount(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/count\",\n      ...options\n    });\n  }\n  /**\n   * Deletes records in a collection. Can filter by IDs or metadata.\n   */\n  static collectionDelete(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/delete\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Forks an existing collection.\n   */\n  static forkCollection(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/fork\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Retrieves records from a collection by ID or metadata filter.\n   */\n  static collectionGet(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/get\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Query a collection in a variety of ways, including vector search, metadata filtering, and full-text search\n   */\n  static collectionQuery(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/query\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Updates records in a collection by ID.\n   */\n  static collectionUpdate(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/update\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Upserts records in a collection (create if not exists, otherwise update).\n   */\n  static collectionUpsert(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/upsert\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Retrieves the total number of collections in a given database.\n   */\n  static countCollections(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections_count\",\n      ...options\n    });\n  }\n  /**\n   * Returns the version of the server.\n   */\n  static version(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/version\",\n      ...options\n    });\n  }\n};\n\n// src/errors.ts\nvar ChromaError = class extends Error {\n  constructor(name, message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = name;\n  }\n};\nvar ChromaConnectionError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaConnectionError\";\n  }\n};\nvar ChromaServerError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaServerError\";\n  }\n};\nvar ChromaClientError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaClientError\";\n  }\n};\nvar ChromaUnauthorizedError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaAuthError\";\n  }\n};\nvar ChromaForbiddenError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaForbiddenError\";\n  }\n};\nvar ChromaNotFoundError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaNotFoundError\";\n  }\n};\nvar ChromaValueError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaValueError\";\n  }\n};\nvar InvalidCollectionError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"InvalidCollectionError\";\n  }\n};\nvar InvalidArgumentError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"InvalidArgumentError\";\n  }\n};\nvar ChromaUniqueError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaUniqueError\";\n  }\n};\nvar ChromaQuotaExceededError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaQuotaExceededError\";\n  }\n};\nvar ChromaRateLimitError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaRateLimitError\";\n  }\n};\nfunction createErrorByType(type, message) {\n  switch (type) {\n    case \"InvalidCollection\":\n      return new InvalidCollectionError(message);\n    case \"InvalidArgumentError\":\n      return new InvalidArgumentError(message);\n    default:\n      return void 0;\n  }\n}\n\n// src/utils.ts\nvar DEFAULT_TENANT = \"default_tenant\";\nvar DEFAULT_DATABASE = \"default_database\";\nvar defaultAdminClientArgs = {\n  host: \"localhost\",\n  port: 8e3,\n  ssl: false\n};\nvar defaultChromaClientArgs = {\n  ...defaultAdminClientArgs,\n  tenant: DEFAULT_TENANT,\n  database: DEFAULT_DATABASE\n};\nvar normalizeMethod = (method) => {\n  if (method) {\n    switch (method.toUpperCase()) {\n      case \"GET\":\n        return \"GET\";\n      case \"POST\":\n        return \"POST\";\n      case \"PUT\":\n        return \"PUT\";\n      case \"DELETE\":\n        return \"DELETE\";\n      case \"HEAD\":\n        return \"HEAD\";\n      case \"CONNECT\":\n        return \"CONNECT\";\n      case \"OPTIONS\":\n        return \"OPTIONS\";\n      case \"PATCH\":\n        return \"PATCH\";\n      case \"TRACE\":\n        return \"TRACE\";\n      default:\n        return void 0;\n    }\n  }\n  return void 0;\n};\nvar validateRecordSetLengthConsistency = (recordSet) => {\n  const lengths = Object.entries(recordSet).filter(\n    ([field, value]) => recordSetFields.includes(field) && value !== void 0\n  ).map(([field, value]) => [field, value.length]);\n  if (lengths.length === 0) {\n    throw new ChromaValueError(\n      `At least one of ${recordSetFields.join(\", \")} must be provided`\n    );\n  }\n  const zeroLength = lengths.filter(([_2, length]) => length === 0).map(([field, _2]) => field);\n  if (zeroLength.length > 0) {\n    throw new ChromaValueError(\n      `Non-empty lists are required for ${zeroLength.join(\", \")}`\n    );\n  }\n  if (new Set(lengths.map(([_2, length]) => length)).size > 1) {\n    throw new ChromaValueError(\n      `Unequal lengths for fields ${lengths.map(([field, _2]) => field).join(\", \")}`\n    );\n  }\n};\nvar validateEmbeddings = ({\n  embeddings,\n  fieldName = \"embeddings\"\n}) => {\n  if (!Array.isArray(embeddings)) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be an array, but got ${typeof embeddings}`\n    );\n  }\n  if (embeddings.length === 0) {\n    throw new ChromaValueError(\n      \"Expected embeddings to be an array with at least one item\"\n    );\n  }\n  if (!embeddings.filter((e) => e.every((n) => typeof n === \"number\"))) {\n    throw new ChromaValueError(\n      \"Expected each embedding to be an array of numbers\"\n    );\n  }\n  embeddings.forEach((embedding, i) => {\n    if (embedding.length === 0) {\n      throw new ChromaValueError(\n        `Expected each embedding to be a non-empty array of numbers, but got an empty array at index ${i}`\n      );\n    }\n  });\n};\nvar validateDocuments = ({\n  documents,\n  nullable = false,\n  fieldName = \"documents\"\n}) => {\n  if (!Array.isArray(documents)) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be an array, but got ${typeof documents}`\n    );\n  }\n  if (documents.length === 0) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be a non-empty list`\n    );\n  }\n  documents.forEach((document) => {\n    if (!nullable && typeof document !== \"string\" && !document) {\n      throw new ChromaValueError(\n        `Expected each document to be a string, but got ${typeof document}`\n      );\n    }\n  });\n};\nvar validateIDs = (ids) => {\n  if (!Array.isArray(ids)) {\n    throw new ChromaValueError(\n      `Expected 'ids' to be an array, but got ${typeof ids}`\n    );\n  }\n  if (ids.length === 0) {\n    throw new ChromaValueError(\"Expected 'ids' to be a non-empty list\");\n  }\n  const nonStrings = ids.map((id, i) => [id, i]).filter(([id, _2]) => typeof id !== \"string\").map(([_2, i]) => i);\n  if (nonStrings.length > 0) {\n    throw new ChromaValueError(\n      `Found non-string IDs at ${nonStrings.join(\", \")}`\n    );\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const duplicates = ids.filter((id) => {\n    if (seen.has(id)) {\n      return id;\n    }\n    seen.add(id);\n  });\n  let message = \"Expected IDs to be unique, but found duplicates of\";\n  if (duplicates.length > 0 && duplicates.length <= 5) {\n    throw new ChromaValueError(`${message} ${duplicates.join(\", \")}`);\n  }\n  if (duplicates.length > 0) {\n    throw new ChromaValueError(\n      `${message} ${duplicates.slice(0, 5).join(\", \")}, ..., ${duplicates.slice(duplicates.length - 5).join(\", \")}`\n    );\n  }\n};\nvar validateMetadata = (metadata) => {\n  if (!metadata) {\n    return;\n  }\n  if (Object.keys(metadata).length === 0) {\n    throw new ChromaValueError(\"Expected metadata to be non-empty\");\n  }\n  if (!Object.values(metadata).every(\n    (v) => v === null || v === void 0 || typeof v === \"string\" || typeof v === \"number\" || typeof v === \"boolean\"\n  )) {\n    throw new ChromaValueError(\n      \"Expected metadata to be a string, number, boolean, or nullable\"\n    );\n  }\n};\nvar validateMetadatas = (metadatas) => {\n  if (!Array.isArray(metadatas)) {\n    throw new ChromaValueError(\n      `Expected metadatas to be an array, but got ${typeof metadatas}`\n    );\n  }\n  metadatas.forEach((metadata) => validateMetadata(metadata));\n};\nvar validateBaseRecordSet = ({\n  recordSet,\n  update = false,\n  embeddingsField = \"embeddings\",\n  documentsField = \"documents\"\n}) => {\n  if (!recordSet.embeddings && !recordSet.documents && !update) {\n    throw new ChromaValueError(\n      `At least one of '${embeddingsField}' and '${documentsField}' must be provided`\n    );\n  }\n  if (recordSet.embeddings) {\n    validateEmbeddings({\n      embeddings: recordSet.embeddings,\n      fieldName: embeddingsField\n    });\n  }\n  if (recordSet.documents) {\n    validateDocuments({\n      documents: recordSet.documents,\n      fieldName: documentsField\n    });\n  }\n  if (recordSet.metadatas) {\n    validateMetadatas(recordSet.metadatas);\n  }\n};\nvar validateMaxBatchSize = (recordSetLength, maxBatchSize) => {\n  if (recordSetLength > maxBatchSize) {\n    throw new ChromaValueError(\n      `Record set length ${recordSetLength} exceeds max batch size ${maxBatchSize}`\n    );\n  }\n};\nvar validateWhere = (where) => {\n  if (typeof where !== \"object\") {\n    throw new ChromaValueError(\"Expected where to be a non-empty object\");\n  }\n  if (Object.keys(where).length != 1) {\n    throw new ChromaValueError(\n      `Expected 'where' to have exactly one operator, but got ${Object.keys(where).length}`\n    );\n  }\n  Object.entries(where).forEach(([key, value]) => {\n    if (key !== \"$and\" && key !== \"$or\" && key !== \"$in\" && key !== \"$nin\" && ![\"string\", \"number\", \"boolean\", \"object\"].includes(typeof value)) {\n      throw new ChromaValueError(\n        `Expected 'where' value to be a string, number, boolean, or an operator expression, but got ${value}`\n      );\n    }\n    if (key === \"$and\" || key === \"$or\") {\n      if (Object.keys(value).length <= 1) {\n        throw new ChromaValueError(\n          `Expected 'where' value for $and or $or to be a list of 'where' expressions, but got ${value}`\n        );\n      }\n      value.forEach((w2) => validateWhere(w2));\n      return;\n    }\n    if (typeof value === \"object\") {\n      if (Object.keys(value).length != 1) {\n        throw new ChromaValueError(\n          `Expected operator expression to have one operator, but got ${value}`\n        );\n      }\n      const [operator, operand] = Object.entries(value)[0];\n      if ([\"$gt\", \"$gte\", \"$lt\", \"$lte\"].includes(operator) && typeof operand !== \"number\") {\n        throw new ChromaValueError(\n          `Expected operand value to be a number for ${operator}, but got ${typeof operand}`\n        );\n      }\n      if ([\"$in\", \"$nin\"].includes(operator) && !Array.isArray(operand)) {\n        throw new ChromaValueError(\n          `Expected operand value to be an array for ${operator}, but got ${operand}`\n        );\n      }\n      if (![\"$gt\", \"$gte\", \"$lt\", \"$lte\", \"$ne\", \"$eq\", \"$in\", \"$nin\"].includes(\n        operator\n      )) {\n        throw new ChromaValueError(\n          `Expected operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, but got ${operator}`\n        );\n      }\n      if (![\"string\", \"number\", \"boolean\"].includes(typeof operand) && !Array.isArray(operand)) {\n        throw new ChromaValueError(\n          \"Expected operand value to be a string, number, boolean, or a list of those types\"\n        );\n      }\n      if (Array.isArray(operand) && (operand.length === 0 || !operand.every((item) => typeof item === typeof operand[0]))) {\n        throw new ChromaValueError(\n          \"Expected 'where' operand value to be a non-empty list and all values to be of the same type\"\n        );\n      }\n    }\n  });\n};\nvar validateWhereDocument = (whereDocument) => {\n  if (typeof whereDocument !== \"object\") {\n    throw new ChromaValueError(\n      \"Expected 'whereDocument' to be a non-empty object\"\n    );\n  }\n  if (Object.keys(whereDocument).length != 1) {\n    throw new ChromaValueError(\n      `Expected 'whereDocument' to have exactly one operator, but got ${whereDocument}`\n    );\n  }\n  const [operator, operand] = Object.entries(whereDocument)[0];\n  if (![\n    \"$contains\",\n    \"$not_contains\",\n    \"$matches\",\n    \"$not_matches\",\n    \"$regex\",\n    \"$not_regex\",\n    \"$and\",\n    \"$or\"\n  ].includes(operator)) {\n    throw new ChromaValueError(\n      `Expected 'whereDocument' operator to be one of $contains, $not_contains, $matches, $not_matches, $regex, $not_regex, $and, or $or, but got ${operator}`\n    );\n  }\n  if (operator === \"$and\" || operator === \"$or\") {\n    if (!Array.isArray(operand)) {\n      throw new ChromaValueError(\n        `Expected operand for ${operator} to be a list of 'whereDocument' expressions, but got ${operand}`\n      );\n    }\n    if (operand.length <= 1) {\n      throw new ChromaValueError(\n        `Expected 'whereDocument' operand for ${operator} to be a list with at least two 'whereDocument' expressions`\n      );\n    }\n    operand.forEach((item) => validateWhereDocument(item));\n  }\n  if ((operand === \"$contains\" || operand === \"$not_contains\" || operand === \"$regex\" || operand === \"$not_regex\") && (typeof operator !== \"string\" || operator.length === 0)) {\n    throw new ChromaValueError(\n      `Expected operand for ${operator} to be a non empty string, but got ${operand}`\n    );\n  }\n};\nvar validateInclude = ({\n  include,\n  exclude\n}) => {\n  if (!Array.isArray(include)) {\n    throw new ChromaValueError(\"Expected 'include' to be a non-empty array\");\n  }\n  const validValues = Object.keys(IncludeEnum);\n  include.forEach((item) => {\n    if (typeof item !== \"string\") {\n      throw new ChromaValueError(\"Expected 'include' items to be strings\");\n    }\n    if (!validValues.includes(item)) {\n      throw new ChromaValueError(\n        `Expected 'include' items to be one of ${validValues.join(\n          \", \"\n        )}, but got ${item}`\n      );\n    }\n    if (exclude?.includes(item)) {\n      throw new ChromaValueError(`${item} is not allowed for this operation`);\n    }\n  });\n};\nvar validateNResults = (nResults) => {\n  if (typeof nResults !== \"number\") {\n    throw new ChromaValueError(\n      `Expected 'nResults' to be a number, but got ${typeof nResults}`\n    );\n  }\n  if (nResults <= 0) {\n    throw new ChromaValueError(\"Number of requested results has to positive\");\n  }\n};\nvar parseConnectionPath = (path) => {\n  try {\n    const url = new URL(path);\n    const ssl = url.protocol === \"https:\";\n    const host = url.hostname;\n    const port = url.port;\n    return {\n      ssl,\n      host,\n      port: Number(port)\n    };\n  } catch {\n    throw new ChromaValueError(`Invalid URL: ${path}`);\n  }\n};\nvar packEmbedding = (embedding) => {\n  const buffer = new ArrayBuffer(embedding.length * 4);\n  const view = new Float32Array(buffer);\n  for (let i = 0; i < embedding.length; i++) {\n    view[i] = embedding[i];\n  }\n  return buffer;\n};\nvar embeddingsToBase64Bytes = (embeddings) => {\n  return embeddings.map((embedding) => {\n    const buffer = packEmbedding(embedding);\n    const uint8Array = new Uint8Array(buffer);\n    const binaryString = Array.from(\n      uint8Array,\n      (byte) => String.fromCharCode(byte)\n    ).join(\"\");\n    return btoa(binaryString);\n  });\n};\n\n// src/embedding-function.ts\nvar knownEmbeddingFunctions = /* @__PURE__ */ new Map();\nvar registerEmbeddingFunction = (name, fn) => {\n  if (knownEmbeddingFunctions.has(name)) {\n    throw new ChromaValueError(\n      `Embedding function with name ${name} is already registered.`\n    );\n  }\n  knownEmbeddingFunctions.set(name, fn);\n};\nvar getEmbeddingFunction = async (collectionName, efConfig) => {\n  if (!efConfig) {\n    console.warn(\n      `No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  }\n  if (efConfig.type === \"legacy\") {\n    console.warn(\n      `No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  }\n  const name = efConfig.name;\n  const embeddingFunction = knownEmbeddingFunctions.get(name);\n  if (!embeddingFunction) {\n    console.warn(\n      `Collection ${collectionName} was created with the ${embeddingFunction} embedding function. However, the @chroma-core/${embeddingFunction} package is not install. 'add' and 'query' will fail unless you provide them embeddings directly, or install the @chroma-core/${embeddingFunction} package.`\n    );\n    return void 0;\n  }\n  let constructorConfig = efConfig.type === \"known\" ? efConfig.config : {};\n  try {\n    if (embeddingFunction.buildFromConfig) {\n      return embeddingFunction.buildFromConfig(constructorConfig);\n    }\n    console.warn(\n      `Embedding function ${name} does not define a 'buildFromConfig' function. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  } catch (e) {\n    console.warn(\n      `Embedding function ${name} failed to build with config: ${constructorConfig}. 'add' and 'query' will fail unless you provide them embeddings directly. Error: ${e}`\n    );\n    return void 0;\n  }\n};\nvar serializeEmbeddingFunction = ({\n  embeddingFunction,\n  configEmbeddingFunction\n}) => {\n  if (embeddingFunction && configEmbeddingFunction) {\n    throw new ChromaValueError(\n      \"Embedding function provided when already defined in the collection configuration\"\n    );\n  }\n  if (!embeddingFunction && !configEmbeddingFunction) {\n    return void 0;\n  }\n  const ef = embeddingFunction || configEmbeddingFunction;\n  if (!ef.getConfig || !ef.name || !ef.constructor.buildFromConfig) {\n    return { type: \"legacy\" };\n  }\n  if (ef.validateConfig) ef.validateConfig(ef.getConfig());\n  return {\n    name: ef.name,\n    type: \"known\",\n    config: ef.getConfig()\n  };\n};\nvar getDefaultEFConfig = async () => {\n  try {\n    const { DefaultEmbeddingFunction } = await __webpack_require__.e(/*! import() */ \"_7145\").then(__webpack_require__.t.bind(__webpack_require__, /*! @chroma-core/default-embed */ \"?7145\", 19));\n    if (!knownEmbeddingFunctions.has(new DefaultEmbeddingFunction().name)) {\n      registerEmbeddingFunction(\"default\", DefaultEmbeddingFunction);\n    }\n  } catch (e) {\n    console.error(e);\n    throw new Error(\n      \"Cannot instantiate a collection with the DefaultEmbeddingFunction. Please install @chroma-core/default-embed, or provide a different embedding function\"\n    );\n  }\n  return {\n    name: \"default\",\n    type: \"known\",\n    config: {}\n  };\n};\n\n// src/collection-configuration.ts\nvar processCreateCollectionConfig = async ({\n  configuration,\n  embeddingFunction\n}) => {\n  if (configuration?.hnsw && configuration?.spann) {\n    throw new ChromaValueError(\n      \"Cannot specify both HNSW and SPANN configurations\"\n    );\n  }\n  let embeddingFunctionConfiguration = serializeEmbeddingFunction({\n    embeddingFunction: embeddingFunction ?? void 0,\n    configEmbeddingFunction: configuration?.embeddingFunction\n  });\n  if (!embeddingFunctionConfiguration && embeddingFunction !== null) {\n    embeddingFunctionConfiguration = await getDefaultEFConfig();\n  }\n  return {\n    ...configuration || {},\n    embedding_function: embeddingFunctionConfiguration\n  };\n};\nvar processUpdateCollectionConfig = async ({\n  collectionName,\n  currentConfiguration,\n  currentEmbeddingFunction,\n  newConfiguration\n}) => {\n  if (newConfiguration.hnsw && typeof newConfiguration.hnsw !== \"object\") {\n    throw new ChromaValueError(\n      \"Invalid HNSW config provided in UpdateCollectionConfiguration\"\n    );\n  }\n  if (newConfiguration.spann && typeof newConfiguration.spann !== \"object\") {\n    throw new ChromaValueError(\n      \"Invalid SPANN config provided in UpdateCollectionConfiguration\"\n    );\n  }\n  const embeddingFunction = currentEmbeddingFunction || await getEmbeddingFunction(\n    collectionName,\n    currentConfiguration.embeddingFunction ?? void 0\n  );\n  const newEmbeddingFunction = newConfiguration.embeddingFunction;\n  if (embeddingFunction && embeddingFunction.validateConfigUpdate && newEmbeddingFunction && newEmbeddingFunction.getConfig) {\n    embeddingFunction.validateConfigUpdate(newEmbeddingFunction.getConfig());\n  }\n  return {\n    updateConfiguration: {\n      hnsw: newConfiguration.hnsw,\n      spann: newConfiguration.spann,\n      embedding_function: newEmbeddingFunction && serializeEmbeddingFunction({ embeddingFunction: newEmbeddingFunction })\n    },\n    updateEmbeddingFunction: newEmbeddingFunction\n  };\n};\n\n// src/collection.ts\nvar CollectionImpl = class _CollectionImpl {\n  /**\n   * Creates a new CollectionAPIImpl instance.\n   * @param options - Configuration for the collection API\n   */\n  constructor({\n    chromaClient,\n    apiClient,\n    id,\n    name,\n    metadata,\n    configuration,\n    embeddingFunction\n  }) {\n    this.chromaClient = chromaClient;\n    this.apiClient = apiClient;\n    this.id = id;\n    this._name = name;\n    this._metadata = metadata;\n    this._configuration = configuration;\n    this._embeddingFunction = embeddingFunction;\n  }\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n  }\n  get configuration() {\n    return this._configuration;\n  }\n  set configuration(configuration) {\n    this._configuration = configuration;\n  }\n  get metadata() {\n    return this._metadata;\n  }\n  set metadata(metadata) {\n    this._metadata = metadata;\n  }\n  get embeddingFunction() {\n    return this._embeddingFunction;\n  }\n  set embeddingFunction(embeddingFunction) {\n    this._embeddingFunction = embeddingFunction;\n  }\n  async path() {\n    const clientPath = await this.chromaClient._path();\n    return {\n      ...clientPath,\n      collection_id: this.id\n    };\n  }\n  async embed(documents) {\n    if (!this._embeddingFunction) {\n      throw new ChromaValueError(\n        \"Embedding function must be defined for operations requiring embeddings.\"\n      );\n    }\n    return await this._embeddingFunction.generate(documents);\n  }\n  async prepareRecords({\n    recordSet,\n    update = false\n  }) {\n    const maxBatchSize = await this.chromaClient.getMaxBatchSize();\n    validateRecordSetLengthConsistency(recordSet);\n    validateIDs(recordSet.ids);\n    validateBaseRecordSet({ recordSet, update });\n    validateMaxBatchSize(recordSet.ids.length, maxBatchSize);\n    if (!recordSet.embeddings && recordSet.documents) {\n      recordSet.embeddings = await this.embed(recordSet.documents);\n    }\n    const preparedRecordSet = { ...recordSet };\n    const base64Supported = await this.chromaClient.supportsBase64Encoding();\n    if (base64Supported && recordSet.embeddings) {\n      preparedRecordSet.embeddings = embeddingsToBase64Bytes(\n        recordSet.embeddings\n      );\n    }\n    return preparedRecordSet;\n  }\n  validateGet(include, ids, where, whereDocument) {\n    validateInclude({ include, exclude: [\"distances\"] });\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n  }\n  async prepareQuery(recordSet, include, ids, where, whereDocument, nResults) {\n    validateBaseRecordSet({\n      recordSet,\n      embeddingsField: \"queryEmbeddings\",\n      documentsField: \"queryTexts\"\n    });\n    validateInclude({ include });\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n    if (nResults) validateNResults(nResults);\n    let embeddings;\n    if (!recordSet.embeddings) {\n      embeddings = await this.embed(recordSet.documents);\n    } else {\n      embeddings = recordSet.embeddings;\n    }\n    return {\n      ...recordSet,\n      ids,\n      embeddings\n    };\n  }\n  validateDelete(ids, where, whereDocument) {\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n  }\n  async count() {\n    const { data } = await DefaultService.collectionCount({\n      client: this.apiClient,\n      path: await this.path()\n    });\n    return data;\n  }\n  async add({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris\n  }) {\n    const recordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris\n    };\n    const preparedRecordSet = await this.prepareRecords({ recordSet });\n    await DefaultService.collectionAdd({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        documents: preparedRecordSet.documents,\n        metadatas: preparedRecordSet.metadatas,\n        uris: preparedRecordSet.uris\n      }\n    });\n  }\n  async get(args = {}) {\n    const {\n      ids,\n      where,\n      limit,\n      offset,\n      whereDocument,\n      include = [\"documents\", \"metadatas\"]\n    } = args;\n    this.validateGet(include, ids, where, whereDocument);\n    const { data } = await DefaultService.collectionGet({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids,\n        where,\n        limit,\n        offset,\n        where_document: whereDocument,\n        include\n      }\n    });\n    return new GetResult({\n      documents: data.documents ?? [],\n      embeddings: data.embeddings ?? [],\n      ids: data.ids,\n      include: data.include,\n      metadatas: data.metadatas ?? [],\n      uris: data.uris ?? []\n    });\n  }\n  async peek({ limit = 10 }) {\n    return this.get({ limit });\n  }\n  async query({\n    queryEmbeddings,\n    queryTexts,\n    queryURIs,\n    ids,\n    nResults = 10,\n    where,\n    whereDocument,\n    include = [\"metadatas\", \"documents\", \"distances\"]\n  }) {\n    const recordSet = {\n      embeddings: queryEmbeddings,\n      documents: queryTexts,\n      uris: queryURIs\n    };\n    const queryRecordSet = await this.prepareQuery(\n      recordSet,\n      include,\n      ids,\n      where,\n      whereDocument,\n      nResults\n    );\n    const { data } = await DefaultService.collectionQuery({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: queryRecordSet.ids,\n        include,\n        n_results: nResults,\n        query_embeddings: queryRecordSet.embeddings,\n        where,\n        where_document: whereDocument\n      }\n    });\n    return new QueryResult({\n      distances: data.distances ?? [],\n      documents: data.documents ?? [],\n      embeddings: data.embeddings ?? [],\n      ids: data.ids ?? [],\n      include: data.include,\n      metadatas: data.metadatas ?? [],\n      uris: data.uris ?? []\n    });\n  }\n  async modify({\n    name,\n    metadata,\n    configuration\n  }) {\n    if (name) this.name = name;\n    if (metadata) {\n      validateMetadata(metadata);\n      this.metadata = metadata;\n    }\n    const { updateConfiguration, updateEmbeddingFunction } = configuration ? await processUpdateCollectionConfig({\n      collectionName: this.name,\n      currentConfiguration: this.configuration,\n      newConfiguration: configuration,\n      currentEmbeddingFunction: this.embeddingFunction\n    }) : {};\n    if (updateEmbeddingFunction) {\n      this.embeddingFunction = updateEmbeddingFunction;\n    }\n    if (updateConfiguration) {\n      this.configuration = {\n        hnsw: { ...this.configuration.hnsw, ...updateConfiguration.hnsw },\n        spann: { ...this.configuration.spann, ...updateConfiguration.spann },\n        embeddingFunction: updateConfiguration.embedding_function\n      };\n    }\n    await DefaultService.updateCollection({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        new_name: name,\n        new_metadata: metadata,\n        new_configuration: updateConfiguration\n      }\n    });\n  }\n  async fork({ name }) {\n    const { data } = await DefaultService.forkCollection({\n      client: this.apiClient,\n      path: await this.path(),\n      body: { new_name: name }\n    });\n    return new _CollectionImpl({\n      chromaClient: this.chromaClient,\n      apiClient: this.apiClient,\n      name: data.name,\n      id: data.id,\n      embeddingFunction: this._embeddingFunction,\n      metadata: data.metadata ?? void 0,\n      configuration: data.configuration_json\n    });\n  }\n  async update({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris\n  }) {\n    const recordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris\n    };\n    const preparedRecordSet = await this.prepareRecords({\n      recordSet,\n      update: true\n    });\n    await DefaultService.collectionUpdate({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        metadatas: preparedRecordSet.metadatas,\n        uris: preparedRecordSet.uris,\n        documents: preparedRecordSet.documents\n      }\n    });\n  }\n  async upsert({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris\n  }) {\n    const recordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris\n    };\n    const preparedRecordSet = await this.prepareRecords({\n      recordSet\n    });\n    await DefaultService.collectionUpsert({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        metadatas: preparedRecordSet.metadatas,\n        uris: preparedRecordSet.uris,\n        documents: preparedRecordSet.documents\n      }\n    });\n  }\n  async delete({\n    ids,\n    where,\n    whereDocument\n  }) {\n    this.validateDelete(ids, where, whereDocument);\n    await DefaultService.collectionDelete({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids,\n        where,\n        where_document: whereDocument\n      }\n    });\n  }\n};\n\n// src/next.ts\nfunction withChroma(userNextConfig = {}) {\n  const originalWebpackFunction = userNextConfig.webpack;\n  const newWebpackFunction = (config, options) => {\n    if (!Array.isArray(config.externals)) {\n      config.externals = [];\n    }\n    const externalsToAdd = [\"@huggingface/transformers\", \"chromadb\"];\n    for (const ext of externalsToAdd) {\n      if (!config.externals.includes(ext)) {\n        config.externals.push(ext);\n      }\n    }\n    if (typeof originalWebpackFunction === \"function\") {\n      return originalWebpackFunction(config, options);\n    }\n    return config;\n  };\n  return {\n    ...userNextConfig,\n    webpack: newWebpackFunction\n  };\n}\n\n// src/chroma-fetch.ts\nvar offlineError = (error) => {\n  return Boolean(\n    (error?.name === \"TypeError\" || error?.name === \"FetchError\") && (error.message?.includes(\"fetch failed\") || error.message?.includes(\"Failed to fetch\") || error.message?.includes(\"ENOTFOUND\"))\n  );\n};\nvar chromaFetch = async (input, init) => {\n  let response;\n  try {\n    response = await fetch(input, init);\n  } catch (err) {\n    if (offlineError(err)) {\n      throw new ChromaConnectionError(\n        \"Failed to connect to chromadb. Make sure your server is running and try again. If you are running from a browser, make sure that your chromadb instance is configured to allow requests from the current origin using the CHROMA_SERVER_CORS_ALLOW_ORIGINS environment variable.\"\n      );\n    }\n    throw new ChromaConnectionError(\"Failed to connect to Chroma\");\n  }\n  if (response.ok) {\n    return response;\n  }\n  switch (response.status) {\n    case 400:\n      let status = \"Bad Request\";\n      try {\n        const responseBody = await response.json();\n        status = responseBody.message || status;\n      } catch {\n      }\n      throw new ChromaClientError(\n        `Bad request to ${input.url || \"Chroma\"} with status: ${status}`\n      );\n    case 401:\n      throw new ChromaUnauthorizedError(`Unauthorized`);\n    case 403:\n      throw new ChromaForbiddenError(\n        `You do not have permission to access the requested resource.`\n      );\n    case 404:\n      throw new ChromaNotFoundError(\n        `The requested resource could not be found`\n      );\n    case 409:\n      throw new ChromaUniqueError(\"The resource already exists\");\n    case 422:\n      const body = await response.json();\n      if (body && body.message && (body.message.startsWith(\"Quota exceeded\") || body.message.startsWith(\"Billing limit exceeded\"))) {\n        throw new ChromaQuotaExceededError(body?.message);\n      }\n      break;\n    case 429:\n      throw new ChromaRateLimitError(\"Rate limit exceeded\");\n  }\n  throw new ChromaConnectionError(\n    `Unable to connect to the chromadb server (status: ${response.status}). Please try again later.`\n  );\n};\n\n// src/admin-client.ts\nvar AdminClient = class {\n  /**\n   * Creates a new AdminClient instance.\n   * @param args - Optional configuration for the admin client\n   */\n  constructor(args) {\n    const { host, port, ssl, headers, fetchOptions } = args || defaultAdminClientArgs;\n    const baseUrl = `${ssl ? \"https\" : \"http\"}://${host}:${port}`;\n    const configOptions = {\n      ...fetchOptions,\n      method: normalizeMethod(fetchOptions?.method),\n      baseUrl,\n      headers\n    };\n    this.apiClient = J(w(configOptions));\n    this.apiClient.setConfig({ fetch: chromaFetch });\n  }\n  /**\n   * Creates a new database within a tenant.\n   * @param options - Database creation options\n   * @param options.name - Name of the database to create\n   * @param options.tenant - Tenant that will own the database\n   */\n  async createDatabase({\n    name,\n    tenant\n  }) {\n    await DefaultService.createDatabase({\n      client: this.apiClient,\n      path: { tenant },\n      body: { name }\n    });\n  }\n  /**\n   * Retrieves information about a specific database.\n   * @param options - Database retrieval options\n   * @param options.name - Name of the database to retrieve\n   * @param options.tenant - Tenant that owns the database\n   * @returns Promise resolving to database information\n   */\n  async getDatabase({\n    name,\n    tenant\n  }) {\n    const { data } = await DefaultService.getDatabase({\n      client: this.apiClient,\n      path: { tenant, database: name }\n    });\n    return data;\n  }\n  /**\n   * Deletes a database and all its data.\n   * @param options - Database deletion options\n   * @param options.name - Name of the database to delete\n   * @param options.tenant - Tenant that owns the database\n   * @warning This operation is irreversible and will delete all data\n   */\n  async deleteDatabase({\n    name,\n    tenant\n  }) {\n    await DefaultService.deleteDatabase({\n      client: this.apiClient,\n      path: { tenant, database: name }\n    });\n  }\n  /**\n   * Lists all databases within a tenant.\n   * @param args - Listing parameters including tenant and pagination\n   * @returns Promise resolving to an array of database information\n   */\n  async listDatabases(args) {\n    const { limit = 100, offset = 0, tenant } = args;\n    const { data } = await DefaultService.listDatabases({\n      client: this.apiClient,\n      path: { tenant },\n      query: { limit, offset }\n    });\n    return data;\n  }\n  /**\n   * Creates a new tenant.\n   * @param options - Tenant creation options\n   * @param options.name - Name of the tenant to create\n   */\n  async createTenant({ name }) {\n    await DefaultService.createTenant({\n      client: this.apiClient,\n      body: { name }\n    });\n  }\n  /**\n   * Retrieves information about a specific tenant.\n   * @param options - Tenant retrieval options\n   * @param options.name - Name of the tenant to retrieve\n   * @returns Promise resolving to the tenant name\n   */\n  async getTenant({ name }) {\n    const { data } = await DefaultService.getTenant({\n      client: this.apiClient,\n      path: { tenant_name: name }\n    });\n    return data.name;\n  }\n};\n\n// src/chroma-client.ts\n\nvar ChromaClient = class {\n  /**\n   * Creates a new ChromaClient instance.\n   * @param args - Configuration options for the client\n   */\n  constructor(args = {}) {\n    let {\n      host = defaultChromaClientArgs.host,\n      port = defaultChromaClientArgs.port,\n      ssl = defaultChromaClientArgs.ssl,\n      tenant = defaultChromaClientArgs.tenant,\n      database = defaultChromaClientArgs.database,\n      headers = defaultChromaClientArgs.headers,\n      fetchOptions = defaultChromaClientArgs.fetchOptions\n    } = args;\n    if (args.path) {\n      console.warn(\n        \"The 'path' argument is deprecated. Please use 'ssl', 'host', and 'port' instead\"\n      );\n      const parsedPath = parseConnectionPath(args.path);\n      ssl = parsedPath.ssl;\n      host = parsedPath.host;\n      port = parsedPath.port;\n    }\n    if (args.auth) {\n      console.warn(\n        \"The 'auth' argument is deprecated. Please use 'headers' instead\"\n      );\n      if (!headers) {\n        headers = {};\n      }\n      if (!headers[\"x-chroma-token\"] && args.auth.tokenHeaderType === \"X_CHROMA_TOKEN\" && args.auth.credentials) {\n        headers[\"x-chroma-token\"] = args.auth.credentials;\n      }\n    }\n    const baseUrl = `${ssl ? \"https\" : \"http\"}://${host}:${port}`;\n    this._tenant = tenant || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_TENANT;\n    this._database = database || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_DATABASE;\n    const configOptions = {\n      ...fetchOptions,\n      method: normalizeMethod(fetchOptions?.method),\n      baseUrl,\n      headers\n    };\n    this.apiClient = J(w(configOptions));\n    this.apiClient.setConfig({ fetch: chromaFetch });\n  }\n  /**\n   * Gets the current tenant name.\n   * @returns The tenant name or undefined if not set\n   */\n  get tenant() {\n    return this._tenant;\n  }\n  set tenant(tenant) {\n    this._tenant = tenant;\n  }\n  /**\n   * Gets the current database name.\n   * @returns The database name or undefined if not set\n   */\n  get database() {\n    return this._database;\n  }\n  set database(database) {\n    this._database = database;\n  }\n  /**\n   * Gets the preflight checks\n   * @returns The preflight checks or undefined if not set\n   */\n  get preflightChecks() {\n    return this._preflightChecks;\n  }\n  set preflightChecks(preflightChecks) {\n    this._preflightChecks = preflightChecks;\n  }\n  /** @ignore */\n  async _path() {\n    if (!this._tenant || !this._database) {\n      const { tenant, databases } = await this.getUserIdentity();\n      const uniqueDBs = [...new Set(databases)];\n      this._tenant = tenant;\n      if (uniqueDBs.length === 0) {\n        throw new ChromaUnauthorizedError(\n          `Your API key does not have access to any DBs for tenant ${this.tenant}`\n        );\n      }\n      if (uniqueDBs.length > 1 || uniqueDBs[0] === \"*\") {\n        throw new ChromaValueError(\n          \"Your API key is scoped to more than 1 DB. Please provide a DB name to the CloudClient constructor\"\n        );\n      }\n      this._database = uniqueDBs[0];\n    }\n    return { tenant: this._tenant, database: this._database };\n  }\n  /**\n   * Gets the user identity information including tenant and accessible databases.\n   * @returns Promise resolving to user identity data\n   */\n  async getUserIdentity() {\n    const { data } = await DefaultService.getUserIdentity({\n      client: this.apiClient\n    });\n    return data;\n  }\n  /**\n   * Sends a heartbeat request to check server connectivity.\n   * @returns Promise resolving to the server's nanosecond heartbeat timestamp\n   */\n  async heartbeat() {\n    const { data } = await DefaultService.heartbeat({\n      client: this.apiClient\n    });\n    return data[\"nanosecond heartbeat\"];\n  }\n  /**\n   * Lists all collections in the current database.\n   * @param args - Optional pagination parameters\n   * @param args.limit - Maximum number of collections to return (default: 100)\n   * @param args.offset - Number of collections to skip (default: 0)\n   * @returns Promise resolving to an array of Collection instances\n   */\n  async listCollections(args) {\n    const { limit = 100, offset = 0 } = args || {};\n    const { data } = await DefaultService.listCollections({\n      client: this.apiClient,\n      path: await this._path(),\n      query: { limit, offset }\n    });\n    return Promise.all(\n      data.map(\n        async (collection) => new CollectionImpl({\n          chromaClient: this,\n          apiClient: this.apiClient,\n          name: collection.name,\n          id: collection.id,\n          embeddingFunction: await getEmbeddingFunction(\n            collection.name,\n            collection.configuration_json.embedding_function ?? void 0\n          ),\n          configuration: collection.configuration_json,\n          metadata: collection.metadata ?? void 0\n        })\n      )\n    );\n  }\n  /**\n   * Gets the total number of collections in the current database.\n   * @returns Promise resolving to the collection count\n   */\n  async countCollections() {\n    const { data } = await DefaultService.countCollections({\n      client: this.apiClient,\n      path: await this._path()\n    });\n    return data;\n  }\n  /**\n   * Creates a new collection with the specified configuration.\n   * @param options - Collection creation options\n   * @param options.name - The name of the collection\n   * @param options.configuration - Optional collection configuration\n   * @param options.metadata - Optional metadata for the collection\n   * @param options.embeddingFunction - Optional embedding function to use. Defaults to `DefaultEmbeddingFunction` from @chroma-core/default-embed\n   * @returns Promise resolving to the created Collection instance\n   * @throws Error if a collection with the same name already exists\n   */\n  async createCollection({\n    name,\n    configuration,\n    metadata,\n    embeddingFunction\n  }) {\n    const collectionConfig = await processCreateCollectionConfig({\n      configuration,\n      embeddingFunction\n    });\n    const { data } = await DefaultService.createCollection({\n      client: this.apiClient,\n      path: await this._path(),\n      body: {\n        name,\n        configuration: collectionConfig,\n        metadata,\n        get_or_create: false\n      }\n    });\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      configuration: data.configuration_json,\n      metadata,\n      embeddingFunction: embeddingFunction ?? await getEmbeddingFunction(\n        data.name,\n        data.configuration_json.embedding_function ?? void 0\n      ),\n      id: data.id\n    });\n  }\n  /**\n   * Retrieves an existing collection by name.\n   * @param options - Collection retrieval options\n   * @param options.name - The name of the collection to retrieve\n   * @param options.embeddingFunction - Optional embedding function. Should match the one used to create the collection.\n   * @returns Promise resolving to the Collection instance\n   * @throws Error if the collection does not exist\n   */\n  async getCollection({\n    name,\n    embeddingFunction\n  }) {\n    const { data } = await DefaultService.getCollection({\n      client: this.apiClient,\n      path: { ...await this._path(), collection_id: name }\n    });\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      configuration: data.configuration_json,\n      metadata: data.metadata ?? void 0,\n      embeddingFunction: embeddingFunction ? embeddingFunction : await getEmbeddingFunction(\n        data.name,\n        data.configuration_json.embedding_function ?? void 0\n      ),\n      id: data.id\n    });\n  }\n  /**\n   * Retrieves multiple collections by name.\n   * @param items - Array of collection names or objects with name and optional embedding function (should match the ones used to create the collections)\n   * @returns Promise resolving to an array of Collection instances\n   */\n  async getCollections(items) {\n    if (items.length === 0) return [];\n    let requestedCollections = items;\n    if (typeof items[0] === \"string\") {\n      requestedCollections = items.map((item) => {\n        return { name: item, embeddingFunction: void 0 };\n      });\n    }\n    let collections = requestedCollections;\n    return Promise.all(\n      collections.map(async (collection) => {\n        return this.getCollection({ ...collection });\n      })\n    );\n  }\n  /**\n   * Gets an existing collection or creates it if it doesn't exist.\n   * @param options - Collection options\n   * @param options.name - The name of the collection\n   * @param options.configuration - Optional collection configuration (used only if creating)\n   * @param options.metadata - Optional metadata for the collection (used only if creating)\n   * @param options.embeddingFunction - Optional embedding function to use\n   * @returns Promise resolving to the Collection instance\n   */\n  async getOrCreateCollection({\n    name,\n    configuration,\n    metadata,\n    embeddingFunction\n  }) {\n    const collectionConfig = await processCreateCollectionConfig({\n      configuration,\n      embeddingFunction\n    });\n    const { data } = await DefaultService.createCollection({\n      client: this.apiClient,\n      path: await this._path(),\n      body: {\n        name,\n        configuration: collectionConfig,\n        metadata,\n        get_or_create: true\n      }\n    });\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      configuration: data.configuration_json,\n      metadata: data.metadata ?? void 0,\n      embeddingFunction: embeddingFunction ?? await getEmbeddingFunction(\n        name,\n        data.configuration_json.embedding_function ?? void 0\n      ),\n      id: data.id\n    });\n  }\n  /**\n   * Deletes a collection and all its data.\n   * @param options - Deletion options\n   * @param options.name - The name of the collection to delete\n   */\n  async deleteCollection({ name }) {\n    await DefaultService.deleteCollection({\n      client: this.apiClient,\n      path: { ...await this._path(), collection_id: name }\n    });\n  }\n  /**\n   * Resets the entire database, deleting all collections and data.\n   * @returns Promise that resolves when the reset is complete\n   * @warning This operation is irreversible and will delete all data\n   */\n  async reset() {\n    await DefaultService.reset({\n      client: this.apiClient\n    });\n  }\n  /**\n   * Gets the version of the Chroma server.\n   * @returns Promise resolving to the server version string\n   */\n  async version() {\n    const { data } = await DefaultService.version({\n      client: this.apiClient\n    });\n    return data;\n  }\n  /**\n   * Gets the preflight checks\n   * @returns Promise resolving to the preflight checks\n   */\n  async getPreflightChecks() {\n    if (!this.preflightChecks) {\n      const { data } = await DefaultService.preFlightChecks({\n        client: this.apiClient\n      });\n      this.preflightChecks = data;\n      return this.preflightChecks;\n    }\n    return this.preflightChecks;\n  }\n  /**\n   * Gets the max batch size\n   * @returns Promise resolving to the max batch size\n   */\n  async getMaxBatchSize() {\n    const preflightChecks = await this.getPreflightChecks();\n    return preflightChecks.max_batch_size ?? -1;\n  }\n  /**\n   * Gets whether base64_encoding is supported by the connected server\n   * @returns Promise resolving to whether base64_encoding is supported\n   */\n  async supportsBase64Encoding() {\n    const preflightChecks = await this.getPreflightChecks();\n    return preflightChecks.supports_base64_encoding ?? false;\n  }\n};\n\n// src/cloud-client.ts\n\nvar CloudClient = class extends ChromaClient {\n  /**\n   * Creates a new CloudClient instance for Chroma Cloud.\n   * @param args - Cloud client configuration options\n   */\n  constructor(args = {}) {\n    const apiKey = args.apiKey || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_API_KEY;\n    if (!apiKey) {\n      throw new ChromaValueError(\n        \"Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable\"\n      );\n    }\n    const tenant = args.tenant || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_TENANT;\n    const database = args.database || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_DATABASE;\n    super({\n      host: \"api.trychroma.com\",\n      port: 8e3,\n      ssl: true,\n      tenant,\n      database,\n      headers: { \"x-chroma-token\": apiKey },\n      fetchOptions: args.fetchOptions\n    });\n    this.tenant = tenant;\n    this.database = database;\n  }\n};\nvar AdminCloudClient = class extends AdminClient {\n  /**\n   * Creates a new AdminCloudClient instance for cloud admin operations.\n   * @param args - Admin cloud client configuration options\n   */\n  constructor(args = {}) {\n    const apiKey = args.apiKey || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_API_KEY;\n    if (!apiKey) {\n      throw new ChromaValueError(\n        \"Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable\"\n      );\n    }\n    super({\n      host: \"api.trychroma.com\",\n      port: 8e3,\n      ssl: true,\n      headers: { \"x-chroma-token\": apiKey },\n      fetchOptions: args.fetchOptions\n    });\n  }\n};\n\n//# sourceMappingURL=chromadb.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hyb21hZGIvZGlzdC9jaHJvbWFkYi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRSxvQ0FBb0MsUUFBUTtBQUNoRztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QWMsT0FBTztBQUNyQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGtDQUFrQyw2Q0FBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZDQUFZO0FBQzlDLHNDQUFzQyw2Q0FBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixrQ0FBa0MsNkNBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBaUNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb25zdGl0dXRpb24vLi9ub2RlX21vZHVsZXMvY2hyb21hZGIvZGlzdC9jaHJvbWFkYi5tanM/ZGU2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBfX3B1YmxpY0ZpZWxkXG59IGZyb20gXCIuL2NodW5rLU5TU01UWEpKLm1qc1wiO1xuXG4vLyBzcmMvZGVuby50c1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzLkRlbm8gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgY29uc3QgT3JpZ2luYWxSZXF1ZXN0ID0gZ2xvYmFsVGhpcy5SZXF1ZXN0O1xuICBjb25zdCBQYXRjaGVkUmVxdWVzdCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IGNsZWFuSW5pdCA9IHsgLi4uaW5pdCB9O1xuICAgICAgaWYgKFwiY2xpZW50XCIgaW4gY2xlYW5Jbml0KSB7XG4gICAgICAgIGRlbGV0ZSBjbGVhbkluaXQuY2xpZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBPcmlnaW5hbFJlcXVlc3QoaW5wdXQsIGNsZWFuSW5pdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JpZ2luYWxSZXF1ZXN0KGlucHV0LCBpbml0KTtcbiAgfTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFBhdGNoZWRSZXF1ZXN0LCBPcmlnaW5hbFJlcXVlc3QpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGF0Y2hlZFJlcXVlc3QsIFwicHJvdG90eXBlXCIsIHtcbiAgICB2YWx1ZTogT3JpZ2luYWxSZXF1ZXN0LnByb3RvdHlwZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGdsb2JhbFRoaXMuUmVxdWVzdCA9IFBhdGNoZWRSZXF1ZXN0O1xufVxuXG4vLyBzcmMvdHlwZXMudHNcbnZhciBiYXNlUmVjb3JkU2V0RmllbGRzID0gW1xuICBcImlkc1wiLFxuICBcImVtYmVkZGluZ3NcIixcbiAgXCJtZXRhZGF0YXNcIixcbiAgXCJkb2N1bWVudHNcIixcbiAgXCJ1cmlzXCJcbl07XG52YXIgcmVjb3JkU2V0RmllbGRzID0gWy4uLmJhc2VSZWNvcmRTZXRGaWVsZHMsIFwiaWRzXCJdO1xudmFyIEluY2x1ZGVFbnVtID0gLyogQF9fUFVSRV9fICovICgoSW5jbHVkZUVudW0yKSA9PiB7XG4gIEluY2x1ZGVFbnVtMltcImRpc3RhbmNlc1wiXSA9IFwiZGlzdGFuY2VzXCI7XG4gIEluY2x1ZGVFbnVtMltcImRvY3VtZW50c1wiXSA9IFwiZG9jdW1lbnRzXCI7XG4gIEluY2x1ZGVFbnVtMltcImVtYmVkZGluZ3NcIl0gPSBcImVtYmVkZGluZ3NcIjtcbiAgSW5jbHVkZUVudW0yW1wibWV0YWRhdGFzXCJdID0gXCJtZXRhZGF0YXNcIjtcbiAgSW5jbHVkZUVudW0yW1widXJpc1wiXSA9IFwidXJpc1wiO1xuICByZXR1cm4gSW5jbHVkZUVudW0yO1xufSkoSW5jbHVkZUVudW0gfHwge30pO1xudmFyIEdldFJlc3VsdCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgR2V0UmVzdWx0IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSByZXN1bHQgZGF0YSBjb250YWluaW5nIGFsbCBmaWVsZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkb2N1bWVudHMsXG4gICAgZW1iZWRkaW5ncyxcbiAgICBpZHMsXG4gICAgaW5jbHVkZSxcbiAgICBtZXRhZGF0YXMsXG4gICAgdXJpc1xuICB9KSB7XG4gICAgdGhpcy5kb2N1bWVudHMgPSBkb2N1bWVudHM7XG4gICAgdGhpcy5lbWJlZGRpbmdzID0gZW1iZWRkaW5ncztcbiAgICB0aGlzLmlkcyA9IGlkcztcbiAgICB0aGlzLmluY2x1ZGUgPSBpbmNsdWRlO1xuICAgIHRoaXMubWV0YWRhdGFzID0gbWV0YWRhdGFzO1xuICAgIHRoaXMudXJpcyA9IHVyaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSByZXN1bHQgdG8gYSByb3ctYmFzZWQgZm9ybWF0IGZvciBlYXNpZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyBpbmNsdWRlIGZpZWxkcyBhbmQgYXJyYXkgb2YgcmVjb3JkIG9iamVjdHNcbiAgICovXG4gIHJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRzLm1hcCgoaWQsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgZG9jdW1lbnQ6IHRoaXMuaW5jbHVkZS5pbmNsdWRlcyhcImRvY3VtZW50c1wiKSA/IHRoaXMuZG9jdW1lbnRzW2luZGV4XSA6IHZvaWQgMCxcbiAgICAgICAgZW1iZWRkaW5nOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJlbWJlZGRpbmdzXCIpID8gdGhpcy5lbWJlZGRpbmdzW2luZGV4XSA6IHZvaWQgMCxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMuaW5jbHVkZS5pbmNsdWRlcyhcIm1ldGFkYXRhc1wiKSA/IHRoaXMubWV0YWRhdGFzW2luZGV4XSA6IHZvaWQgMCxcbiAgICAgICAgdXJpOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJ1cmlzXCIpID8gdGhpcy51cmlzW2luZGV4XSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBRdWVyeVJlc3VsdCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUXVlcnlSZXN1bHQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBkYXRhIC0gVGhlIHF1ZXJ5IHJlc3VsdCBkYXRhIGNvbnRhaW5pbmcgYWxsIGZpZWxkc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGRpc3RhbmNlcyxcbiAgICBkb2N1bWVudHMsXG4gICAgZW1iZWRkaW5ncyxcbiAgICBpZHMsXG4gICAgaW5jbHVkZSxcbiAgICBtZXRhZGF0YXMsXG4gICAgdXJpc1xuICB9KSB7XG4gICAgdGhpcy5kaXN0YW5jZXMgPSBkaXN0YW5jZXM7XG4gICAgdGhpcy5kb2N1bWVudHMgPSBkb2N1bWVudHM7XG4gICAgdGhpcy5lbWJlZGRpbmdzID0gZW1iZWRkaW5ncztcbiAgICB0aGlzLmlkcyA9IGlkcztcbiAgICB0aGlzLmluY2x1ZGUgPSBpbmNsdWRlO1xuICAgIHRoaXMubWV0YWRhdGFzID0gbWV0YWRhdGFzO1xuICAgIHRoaXMudXJpcyA9IHVyaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBxdWVyeSByZXN1bHQgdG8gYSByb3ctYmFzZWQgZm9ybWF0IGZvciBlYXNpZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyBpbmNsdWRlIGZpZWxkcyBhbmQgc3RydWN0dXJlZCBxdWVyeSByZXN1bHRzXG4gICAqL1xuICByb3dzKCkge1xuICAgIGNvbnN0IHF1ZXJpZXMgPSBbXTtcbiAgICBmb3IgKGxldCBxMiA9IDA7IHEyIDwgdGhpcy5pZHMubGVuZ3RoOyBxMisrKSB7XG4gICAgICBjb25zdCByZWNvcmRzID0gdGhpcy5pZHNbcTJdLm1hcCgoaWQsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZG9jdW1lbnQ6IHRoaXMuaW5jbHVkZS5pbmNsdWRlcyhcImRvY3VtZW50c1wiKSA/IHRoaXMuZG9jdW1lbnRzW3EyXVtpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgICAgZW1iZWRkaW5nOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJlbWJlZGRpbmdzXCIpID8gdGhpcy5lbWJlZGRpbmdzW3EyXVtpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgICAgbWV0YWRhdGE6IHRoaXMuaW5jbHVkZS5pbmNsdWRlcyhcIm1ldGFkYXRhc1wiKSA/IHRoaXMubWV0YWRhdGFzW3EyXVtpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgICAgdXJpOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJ1cmlzXCIpID8gdGhpcy51cmlzW3EyXVtpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgICAgZGlzdGFuY2U6IHRoaXMuaW5jbHVkZS5pbmNsdWRlcyhcImRpc3RhbmNlc1wiKSA/IHRoaXMuZGlzdGFuY2VzW3EyXVtpbmRleF0gOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcXVlcmllcy5wdXNoKHJlY29yZHMpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcmllcztcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BoZXktYXBpK2NsaWVudC1mZXRjaEAwLjEwLjBfQGhleS1hcGkrb3BlbmFwaS10c0AwLjY3LjNfdHlwZXNjcmlwdEA1LjguM18vbm9kZV9tb2R1bGVzL0BoZXktYXBpL2NsaWVudC1mZXRjaC9kaXN0L2luZGV4LmpzXG52YXIgQSA9IGFzeW5jICh0LCByKSA9PiB7XG4gIGxldCBlID0gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gYXdhaXQgcih0KSA6IHI7XG4gIGlmIChlKSByZXR1cm4gdC5zY2hlbWUgPT09IFwiYmVhcmVyXCIgPyBgQmVhcmVyICR7ZX1gIDogdC5zY2hlbWUgPT09IFwiYmFzaWNcIiA/IGBCYXNpYyAke2J0b2EoZSl9YCA6IGU7XG59O1xudmFyIFIgPSB7IGJvZHlTZXJpYWxpemVyOiAodCkgPT4gSlNPTi5zdHJpbmdpZnkodCwgKHIsIGUpID0+IHR5cGVvZiBlID09IFwiYmlnaW50XCIgPyBlLnRvU3RyaW5nKCkgOiBlKSB9O1xudmFyIFUgPSAodCkgPT4ge1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFwibGFiZWxcIjpcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICBjYXNlIFwibWF0cml4XCI6XG4gICAgICByZXR1cm4gXCI7XCI7XG4gICAgY2FzZSBcInNpbXBsZVwiOlxuICAgICAgcmV0dXJuIFwiLFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCImXCI7XG4gIH1cbn07XG52YXIgXyA9ICh0KSA9PiB7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJmb3JtXCI6XG4gICAgICByZXR1cm4gXCIsXCI7XG4gICAgY2FzZSBcInBpcGVEZWxpbWl0ZWRcIjpcbiAgICAgIHJldHVybiBcInxcIjtcbiAgICBjYXNlIFwic3BhY2VEZWxpbWl0ZWRcIjpcbiAgICAgIHJldHVybiBcIiUyMFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCIsXCI7XG4gIH1cbn07XG52YXIgRCA9ICh0KSA9PiB7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJsYWJlbFwiOlxuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIGNhc2UgXCJtYXRyaXhcIjpcbiAgICAgIHJldHVybiBcIjtcIjtcbiAgICBjYXNlIFwic2ltcGxlXCI6XG4gICAgICByZXR1cm4gXCIsXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIiZcIjtcbiAgfVxufTtcbnZhciBPID0gKHsgYWxsb3dSZXNlcnZlZDogdCwgZXhwbG9kZTogciwgbmFtZTogZSwgc3R5bGU6IGEsIHZhbHVlOiBpIH0pID0+IHtcbiAgaWYgKCFyKSB7XG4gICAgbGV0IHMgPSAodCA/IGkgOiBpLm1hcCgobCkgPT4gZW5jb2RlVVJJQ29tcG9uZW50KGwpKSkuam9pbihfKGEpKTtcbiAgICBzd2l0Y2ggKGEpIHtcbiAgICAgIGNhc2UgXCJsYWJlbFwiOlxuICAgICAgICByZXR1cm4gYC4ke3N9YDtcbiAgICAgIGNhc2UgXCJtYXRyaXhcIjpcbiAgICAgICAgcmV0dXJuIGA7JHtlfT0ke3N9YDtcbiAgICAgIGNhc2UgXCJzaW1wbGVcIjpcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYCR7ZX09JHtzfWA7XG4gICAgfVxuICB9XG4gIGxldCBvID0gVShhKSwgbiA9IGkubWFwKChzKSA9PiBhID09PSBcImxhYmVsXCIgfHwgYSA9PT0gXCJzaW1wbGVcIiA/IHQgPyBzIDogZW5jb2RlVVJJQ29tcG9uZW50KHMpIDogeSh7IGFsbG93UmVzZXJ2ZWQ6IHQsIG5hbWU6IGUsIHZhbHVlOiBzIH0pKS5qb2luKG8pO1xuICByZXR1cm4gYSA9PT0gXCJsYWJlbFwiIHx8IGEgPT09IFwibWF0cml4XCIgPyBvICsgbiA6IG47XG59O1xudmFyIHkgPSAoeyBhbGxvd1Jlc2VydmVkOiB0LCBuYW1lOiByLCB2YWx1ZTogZSB9KSA9PiB7XG4gIGlmIChlID09IG51bGwpIHJldHVybiBcIlwiO1xuICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiRGVlcGx5LW5lc3RlZCBhcnJheXMvb2JqZWN0cyBhcmVuXFx1MjAxOXQgc3VwcG9ydGVkLiBQcm92aWRlIHlvdXIgb3duIGBxdWVyeVNlcmlhbGl6ZXIoKWAgdG8gaGFuZGxlIHRoZXNlLlwiKTtcbiAgcmV0dXJuIGAke3J9PSR7dCA/IGUgOiBlbmNvZGVVUklDb21wb25lbnQoZSl9YDtcbn07XG52YXIgcSA9ICh7IGFsbG93UmVzZXJ2ZWQ6IHQsIGV4cGxvZGU6IHIsIG5hbWU6IGUsIHN0eWxlOiBhLCB2YWx1ZTogaSB9KSA9PiB7XG4gIGlmIChpIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIGAke2V9PSR7aS50b0lTT1N0cmluZygpfWA7XG4gIGlmIChhICE9PSBcImRlZXBPYmplY3RcIiAmJiAhcikge1xuICAgIGxldCBzID0gW107XG4gICAgT2JqZWN0LmVudHJpZXMoaSkuZm9yRWFjaCgoW2YsIHVdKSA9PiB7XG4gICAgICBzID0gWy4uLnMsIGYsIHQgPyB1IDogZW5jb2RlVVJJQ29tcG9uZW50KHUpXTtcbiAgICB9KTtcbiAgICBsZXQgbCA9IHMuam9pbihcIixcIik7XG4gICAgc3dpdGNoIChhKSB7XG4gICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICByZXR1cm4gYCR7ZX09JHtsfWA7XG4gICAgICBjYXNlIFwibGFiZWxcIjpcbiAgICAgICAgcmV0dXJuIGAuJHtsfWA7XG4gICAgICBjYXNlIFwibWF0cml4XCI6XG4gICAgICAgIHJldHVybiBgOyR7ZX09JHtsfWA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbDtcbiAgICB9XG4gIH1cbiAgbGV0IG8gPSBEKGEpLCBuID0gT2JqZWN0LmVudHJpZXMoaSkubWFwKChbcywgbF0pID0+IHkoeyBhbGxvd1Jlc2VydmVkOiB0LCBuYW1lOiBhID09PSBcImRlZXBPYmplY3RcIiA/IGAke2V9WyR7c31dYCA6IHMsIHZhbHVlOiBsIH0pKS5qb2luKG8pO1xuICByZXR1cm4gYSA9PT0gXCJsYWJlbFwiIHx8IGEgPT09IFwibWF0cml4XCIgPyBvICsgbiA6IG47XG59O1xudmFyIEggPSAvXFx7W157fV0rXFx9L2c7XG52YXIgQiA9ICh7IHBhdGg6IHQsIHVybDogciB9KSA9PiB7XG4gIGxldCBlID0gciwgYSA9IHIubWF0Y2goSCk7XG4gIGlmIChhKSBmb3IgKGxldCBpIG9mIGEpIHtcbiAgICBsZXQgbyA9IGZhbHNlLCBuID0gaS5zdWJzdHJpbmcoMSwgaS5sZW5ndGggLSAxKSwgcyA9IFwic2ltcGxlXCI7XG4gICAgbi5lbmRzV2l0aChcIipcIikgJiYgKG8gPSB0cnVlLCBuID0gbi5zdWJzdHJpbmcoMCwgbi5sZW5ndGggLSAxKSksIG4uc3RhcnRzV2l0aChcIi5cIikgPyAobiA9IG4uc3Vic3RyaW5nKDEpLCBzID0gXCJsYWJlbFwiKSA6IG4uc3RhcnRzV2l0aChcIjtcIikgJiYgKG4gPSBuLnN1YnN0cmluZygxKSwgcyA9IFwibWF0cml4XCIpO1xuICAgIGxldCBsID0gdFtuXTtcbiAgICBpZiAobCA9PSBudWxsKSBjb250aW51ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsKSkge1xuICAgICAgZSA9IGUucmVwbGFjZShpLCBPKHsgZXhwbG9kZTogbywgbmFtZTogbiwgc3R5bGU6IHMsIHZhbHVlOiBsIH0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGwgPT0gXCJvYmplY3RcIikge1xuICAgICAgZSA9IGUucmVwbGFjZShpLCBxKHsgZXhwbG9kZTogbywgbmFtZTogbiwgc3R5bGU6IHMsIHZhbHVlOiBsIH0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocyA9PT0gXCJtYXRyaXhcIikge1xuICAgICAgZSA9IGUucmVwbGFjZShpLCBgOyR7eSh7IG5hbWU6IG4sIHZhbHVlOiBsIH0pfWApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBmID0gZW5jb2RlVVJJQ29tcG9uZW50KHMgPT09IFwibGFiZWxcIiA/IGAuJHtsfWAgOiBsKTtcbiAgICBlID0gZS5yZXBsYWNlKGksIGYpO1xuICB9XG4gIHJldHVybiBlO1xufTtcbnZhciBFID0gKHsgYWxsb3dSZXNlcnZlZDogdCwgYXJyYXk6IHIsIG9iamVjdDogZSB9ID0ge30pID0+IChpKSA9PiB7XG4gIGxldCBvID0gW107XG4gIGlmIChpICYmIHR5cGVvZiBpID09IFwib2JqZWN0XCIpIGZvciAobGV0IG4gaW4gaSkge1xuICAgIGxldCBzID0gaVtuXTtcbiAgICBpZiAocyAhPSBudWxsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzKSkge1xuICAgICAgICBvID0gWy4uLm8sIE8oeyBhbGxvd1Jlc2VydmVkOiB0LCBleHBsb2RlOiB0cnVlLCBuYW1lOiBuLCBzdHlsZTogXCJmb3JtXCIsIHZhbHVlOiBzLCAuLi5yIH0pXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHMgPT0gXCJvYmplY3RcIikge1xuICAgICAgICBvID0gWy4uLm8sIHEoeyBhbGxvd1Jlc2VydmVkOiB0LCBleHBsb2RlOiB0cnVlLCBuYW1lOiBuLCBzdHlsZTogXCJkZWVwT2JqZWN0XCIsIHZhbHVlOiBzLCAuLi5lIH0pXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvID0gWy4uLm8sIHkoeyBhbGxvd1Jlc2VydmVkOiB0LCBuYW1lOiBuLCB2YWx1ZTogcyB9KV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvLmpvaW4oXCImXCIpO1xufTtcbnZhciBQID0gKHQpID0+IHtcbiAgaWYgKCF0KSByZXR1cm4gXCJzdHJlYW1cIjtcbiAgbGV0IHIgPSB0LnNwbGl0KFwiO1wiKVswXT8udHJpbSgpO1xuICBpZiAocikge1xuICAgIGlmIChyLnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi9qc29uXCIpIHx8IHIuZW5kc1dpdGgoXCIranNvblwiKSkgcmV0dXJuIFwianNvblwiO1xuICAgIGlmIChyID09PSBcIm11bHRpcGFydC9mb3JtLWRhdGFcIikgcmV0dXJuIFwiZm9ybURhdGFcIjtcbiAgICBpZiAoW1wiYXBwbGljYXRpb24vXCIsIFwiYXVkaW8vXCIsIFwiaW1hZ2UvXCIsIFwidmlkZW8vXCJdLnNvbWUoKGUpID0+IHIuc3RhcnRzV2l0aChlKSkpIHJldHVybiBcImJsb2JcIjtcbiAgICBpZiAoci5zdGFydHNXaXRoKFwidGV4dC9cIikpIHJldHVybiBcInRleHRcIjtcbiAgfVxufTtcbnZhciBJID0gYXN5bmMgKHsgc2VjdXJpdHk6IHQsIC4uLnIgfSkgPT4ge1xuICBmb3IgKGxldCBlIG9mIHQpIHtcbiAgICBsZXQgYSA9IGF3YWl0IEEoZSwgci5hdXRoKTtcbiAgICBpZiAoIWEpIGNvbnRpbnVlO1xuICAgIGxldCBpID0gZS5uYW1lID8/IFwiQXV0aG9yaXphdGlvblwiO1xuICAgIHN3aXRjaCAoZS5pbikge1xuICAgICAgY2FzZSBcInF1ZXJ5XCI6XG4gICAgICAgIHIucXVlcnkgfHwgKHIucXVlcnkgPSB7fSksIHIucXVlcnlbaV0gPSBhO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb29raWVcIjpcbiAgICAgICAgci5oZWFkZXJzLmFwcGVuZChcIkNvb2tpZVwiLCBgJHtpfT0ke2F9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhlYWRlclwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgci5oZWFkZXJzLnNldChpLCBhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufTtcbnZhciBTID0gKHQpID0+IFcoeyBiYXNlVXJsOiB0LmJhc2VVcmwsIHBhdGg6IHQucGF0aCwgcXVlcnk6IHQucXVlcnksIHF1ZXJ5U2VyaWFsaXplcjogdHlwZW9mIHQucXVlcnlTZXJpYWxpemVyID09IFwiZnVuY3Rpb25cIiA/IHQucXVlcnlTZXJpYWxpemVyIDogRSh0LnF1ZXJ5U2VyaWFsaXplciksIHVybDogdC51cmwgfSk7XG52YXIgVyA9ICh7IGJhc2VVcmw6IHQsIHBhdGg6IHIsIHF1ZXJ5OiBlLCBxdWVyeVNlcmlhbGl6ZXI6IGEsIHVybDogaSB9KSA9PiB7XG4gIGxldCBvID0gaS5zdGFydHNXaXRoKFwiL1wiKSA/IGkgOiBgLyR7aX1gLCBuID0gKHQgPz8gXCJcIikgKyBvO1xuICByICYmIChuID0gQih7IHBhdGg6IHIsIHVybDogbiB9KSk7XG4gIGxldCBzID0gZSA/IGEoZSkgOiBcIlwiO1xuICByZXR1cm4gcy5zdGFydHNXaXRoKFwiP1wiKSAmJiAocyA9IHMuc3Vic3RyaW5nKDEpKSwgcyAmJiAobiArPSBgPyR7c31gKSwgbjtcbn07XG52YXIgQyA9ICh0LCByKSA9PiB7XG4gIGxldCBlID0geyAuLi50LCAuLi5yIH07XG4gIHJldHVybiBlLmJhc2VVcmw/LmVuZHNXaXRoKFwiL1wiKSAmJiAoZS5iYXNlVXJsID0gZS5iYXNlVXJsLnN1YnN0cmluZygwLCBlLmJhc2VVcmwubGVuZ3RoIC0gMSkpLCBlLmhlYWRlcnMgPSB4KHQuaGVhZGVycywgci5oZWFkZXJzKSwgZTtcbn07XG52YXIgeCA9ICguLi50KSA9PiB7XG4gIGxldCByID0gbmV3IEhlYWRlcnMoKTtcbiAgZm9yIChsZXQgZSBvZiB0KSB7XG4gICAgaWYgKCFlIHx8IHR5cGVvZiBlICE9IFwib2JqZWN0XCIpIGNvbnRpbnVlO1xuICAgIGxldCBhID0gZSBpbnN0YW5jZW9mIEhlYWRlcnMgPyBlLmVudHJpZXMoKSA6IE9iamVjdC5lbnRyaWVzKGUpO1xuICAgIGZvciAobGV0IFtpLCBvXSBvZiBhKSBpZiAobyA9PT0gbnVsbCkgci5kZWxldGUoaSk7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvKSkgZm9yIChsZXQgbiBvZiBvKSByLmFwcGVuZChpLCBuKTtcbiAgICBlbHNlIG8gIT09IHZvaWQgMCAmJiByLnNldChpLCB0eXBlb2YgbyA9PSBcIm9iamVjdFwiID8gSlNPTi5zdHJpbmdpZnkobykgOiBvKTtcbiAgfVxuICByZXR1cm4gcjtcbn07XG52YXIgaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9mbnNcIik7XG4gICAgdGhpcy5fZm5zID0gW107XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fZm5zID0gW107XG4gIH1cbiAgZXhpc3RzKHIpIHtcbiAgICByZXR1cm4gdGhpcy5fZm5zLmluZGV4T2YocikgIT09IC0xO1xuICB9XG4gIGVqZWN0KHIpIHtcbiAgICBsZXQgZSA9IHRoaXMuX2Zucy5pbmRleE9mKHIpO1xuICAgIGUgIT09IC0xICYmICh0aGlzLl9mbnMgPSBbLi4udGhpcy5fZm5zLnNsaWNlKDAsIGUpLCAuLi50aGlzLl9mbnMuc2xpY2UoZSArIDEpXSk7XG4gIH1cbiAgdXNlKHIpIHtcbiAgICB0aGlzLl9mbnMgPSBbLi4udGhpcy5fZm5zLCByXTtcbiAgfVxufTtcbnZhciBUID0gKCkgPT4gKHsgZXJyb3I6IG5ldyBoKCksIHJlcXVlc3Q6IG5ldyBoKCksIHJlc3BvbnNlOiBuZXcgaCgpIH0pO1xudmFyIE4gPSBFKHsgYWxsb3dSZXNlcnZlZDogZmFsc2UsIGFycmF5OiB7IGV4cGxvZGU6IHRydWUsIHN0eWxlOiBcImZvcm1cIiB9LCBvYmplY3Q6IHsgZXhwbG9kZTogdHJ1ZSwgc3R5bGU6IFwiZGVlcE9iamVjdFwiIH0gfSk7XG52YXIgUSA9IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbnZhciB3ID0gKHQgPSB7fSkgPT4gKHsgLi4uUiwgaGVhZGVyczogUSwgcGFyc2VBczogXCJhdXRvXCIsIHF1ZXJ5U2VyaWFsaXplcjogTiwgLi4udCB9KTtcbnZhciBKID0gKHQgPSB7fSkgPT4ge1xuICBsZXQgciA9IEModygpLCB0KSwgZSA9ICgpID0+ICh7IC4uLnIgfSksIGEgPSAobikgPT4gKHIgPSBDKHIsIG4pLCBlKCkpLCBpID0gVCgpLCBvID0gYXN5bmMgKG4pID0+IHtcbiAgICBsZXQgcyA9IHsgLi4uciwgLi4ubiwgZmV0Y2g6IG4uZmV0Y2ggPz8gci5mZXRjaCA/PyBnbG9iYWxUaGlzLmZldGNoLCBoZWFkZXJzOiB4KHIuaGVhZGVycywgbi5oZWFkZXJzKSB9O1xuICAgIHMuc2VjdXJpdHkgJiYgYXdhaXQgSSh7IC4uLnMsIHNlY3VyaXR5OiBzLnNlY3VyaXR5IH0pLCBzLmJvZHkgJiYgcy5ib2R5U2VyaWFsaXplciAmJiAocy5ib2R5ID0gcy5ib2R5U2VyaWFsaXplcihzLmJvZHkpKSwgKHMuYm9keSA9PT0gdm9pZCAwIHx8IHMuYm9keSA9PT0gXCJcIikgJiYgcy5oZWFkZXJzLmRlbGV0ZShcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBsZXQgbCA9IFMocyksIGYgPSB7IHJlZGlyZWN0OiBcImZvbGxvd1wiLCAuLi5zIH0sIHUgPSBuZXcgUmVxdWVzdChsLCBmKTtcbiAgICBmb3IgKGxldCBwIG9mIGkucmVxdWVzdC5fZm5zKSB1ID0gYXdhaXQgcCh1LCBzKTtcbiAgICBsZXQgayA9IHMuZmV0Y2gsIGMgPSBhd2FpdCBrKHUpO1xuICAgIGZvciAobGV0IHAgb2YgaS5yZXNwb25zZS5fZm5zKSBjID0gYXdhaXQgcChjLCB1LCBzKTtcbiAgICBsZXQgbSA9IHsgcmVxdWVzdDogdSwgcmVzcG9uc2U6IGMgfTtcbiAgICBpZiAoYy5vaykge1xuICAgICAgaWYgKGMuc3RhdHVzID09PSAyMDQgfHwgYy5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpID09PSBcIjBcIikgcmV0dXJuIHsgZGF0YToge30sIC4uLm0gfTtcbiAgICAgIGxldCBwID0gKHMucGFyc2VBcyA9PT0gXCJhdXRvXCIgPyBQKGMuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikpIDogcy5wYXJzZUFzKSA/PyBcImpzb25cIjtcbiAgICAgIGlmIChwID09PSBcInN0cmVhbVwiKSByZXR1cm4geyBkYXRhOiBjLmJvZHksIC4uLm0gfTtcbiAgICAgIGxldCBiID0gYXdhaXQgY1twXSgpO1xuICAgICAgcmV0dXJuIHAgPT09IFwianNvblwiICYmIChzLnJlc3BvbnNlVmFsaWRhdG9yICYmIGF3YWl0IHMucmVzcG9uc2VWYWxpZGF0b3IoYiksIHMucmVzcG9uc2VUcmFuc2Zvcm1lciAmJiAoYiA9IGF3YWl0IHMucmVzcG9uc2VUcmFuc2Zvcm1lcihiKSkpLCB7IGRhdGE6IGIsIC4uLm0gfTtcbiAgICB9XG4gICAgbGV0IGcgPSBhd2FpdCBjLnRleHQoKTtcbiAgICB0cnkge1xuICAgICAgZyA9IEpTT04ucGFyc2UoZyk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIGxldCBkID0gZztcbiAgICBmb3IgKGxldCBwIG9mIGkuZXJyb3IuX2ZucykgZCA9IGF3YWl0IHAoZywgYywgdSwgcyk7XG4gICAgaWYgKGQgPSBkIHx8IHt9LCBzLnRocm93T25FcnJvcikgdGhyb3cgZDtcbiAgICByZXR1cm4geyBlcnJvcjogZCwgLi4ubSB9O1xuICB9O1xuICByZXR1cm4geyBidWlsZFVybDogUywgY29ubmVjdDogKG4pID0+IG8oeyAuLi5uLCBtZXRob2Q6IFwiQ09OTkVDVFwiIH0pLCBkZWxldGU6IChuKSA9PiBvKHsgLi4ubiwgbWV0aG9kOiBcIkRFTEVURVwiIH0pLCBnZXQ6IChuKSA9PiBvKHsgLi4ubiwgbWV0aG9kOiBcIkdFVFwiIH0pLCBnZXRDb25maWc6IGUsIGhlYWQ6IChuKSA9PiBvKHsgLi4ubiwgbWV0aG9kOiBcIkhFQURcIiB9KSwgaW50ZXJjZXB0b3JzOiBpLCBvcHRpb25zOiAobikgPT4gbyh7IC4uLm4sIG1ldGhvZDogXCJPUFRJT05TXCIgfSksIHBhdGNoOiAobikgPT4gbyh7IC4uLm4sIG1ldGhvZDogXCJQQVRDSFwiIH0pLCBwb3N0OiAobikgPT4gbyh7IC4uLm4sIG1ldGhvZDogXCJQT1NUXCIgfSksIHB1dDogKG4pID0+IG8oeyAuLi5uLCBtZXRob2Q6IFwiUFVUXCIgfSksIHJlcXVlc3Q6IG8sIHNldENvbmZpZzogYSwgdHJhY2U6IChuKSA9PiBvKHsgLi4ubiwgbWV0aG9kOiBcIlRSQUNFXCIgfSkgfTtcbn07XG5cbi8vIHNyYy9hcGkvY2xpZW50Lmdlbi50c1xudmFyIGNsaWVudCA9IEoodyh7XG4gIGJhc2VVcmw6IFwiaHR0cDovL2xvY2FsaG9zdDo4MDAwXCIsXG4gIHRocm93T25FcnJvcjogdHJ1ZVxufSkpO1xuXG4vLyBzcmMvYXBpL3Nkay5nZW4udHNcbnZhciBEZWZhdWx0U2VydmljZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCB1c2VyJ3MgaWRlbnRpdHksIHRlbmFudCwgYW5kIGRhdGFiYXNlcy5cbiAgICovXG4gIHN0YXRpYyBnZXRVc2VySWRlbnRpdHkob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL2F1dGgvaWRlbnRpdHlcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGVhbHRoIGNoZWNrIGVuZHBvaW50IHRoYXQgcmV0dXJucyAyMDAgaWYgdGhlIHNlcnZlciBhbmQgZXhlY3V0b3IgYXJlIHJlYWR5XG4gICAqL1xuICBzdGF0aWMgaGVhbHRoY2hlY2sob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL2hlYWx0aGNoZWNrXCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhlYXJ0YmVhdCBlbmRwb2ludCB0aGF0IHJldHVybnMgYSBuYW5vc2Vjb25kIHRpbWVzdGFtcCBvZiB0aGUgY3VycmVudCB0aW1lLlxuICAgKi9cbiAgc3RhdGljIGhlYXJ0YmVhdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gY2xpZW50KS5nZXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvaGVhcnRiZWF0XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByZS1mbGlnaHQgY2hlY2tzIGVuZHBvaW50IHJlcG9ydGluZyBiYXNpYyByZWFkaW5lc3MgaW5mby5cbiAgICovXG4gIHN0YXRpYyBwcmVGbGlnaHRDaGVja3Mob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3ByZS1mbGlnaHQtY2hlY2tzXCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IGVuZHBvaW50IGFsbG93aW5nIGF1dGhvcml6ZWQgdXNlcnMgdG8gcmVzZXQgdGhlIGRhdGFiYXNlLlxuICAgKi9cbiAgc3RhdGljIHJlc2V0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvcmVzZXRcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0ZW5hbnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlVGVuYW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4aXN0aW5nIHRlbmFudCBieSBuYW1lLlxuICAgKi9cbiAgc3RhdGljIGdldFRlbmFudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnRfbmFtZX1cIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhbiBleGlzdGluZyB0ZW5hbnQgYnkgbmFtZS5cbiAgICovXG4gIHN0YXRpYyB1cGRhdGVUZW5hbnQob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wYXRjaCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnRfbmFtZX1cIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBkYXRhYmFzZXMgZm9yIGEgZ2l2ZW4gdGVuYW50LlxuICAgKi9cbiAgc3RhdGljIGxpc3REYXRhYmFzZXMob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5nZXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXNcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBkYXRhYmFzZSBmb3IgYSBnaXZlbiB0ZW5hbnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlRGF0YWJhc2Uob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgc3BlY2lmaWMgZGF0YWJhc2UuXG4gICAqL1xuICBzdGF0aWMgZGVsZXRlRGF0YWJhc2Uob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5kZWxldGUoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfVwiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBzcGVjaWZpYyBkYXRhYmFzZSBieSBuYW1lLlxuICAgKi9cbiAgc3RhdGljIGdldERhdGFiYXNlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX1cIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIGNvbGxlY3Rpb25zIGluIHRoZSBzcGVjaWZpZWQgZGF0YWJhc2UuXG4gICAqL1xuICBzdGF0aWMgbGlzdENvbGxlY3Rpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnNcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb2xsZWN0aW9uIHVuZGVyIHRoZSBzcGVjaWZpZWQgZGF0YWJhc2UuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQ29sbGVjdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9uc1wiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIGNvbGxlY3Rpb24gaW4gYSBnaXZlbiBkYXRhYmFzZS5cbiAgICovXG4gIHN0YXRpYyBkZWxldGVDb2xsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZGVsZXRlKHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIGNvbGxlY3Rpb24gYnkgSUQgb3IgbmFtZS5cbiAgICovXG4gIHN0YXRpYyBnZXRDb2xsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgY29sbGVjdGlvbidzIG5hbWUgb3IgbWV0YWRhdGEuXG4gICAqL1xuICBzdGF0aWMgdXBkYXRlQ29sbGVjdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnB1dCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfVwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyByZWNvcmRzIHRvIGEgY29sbGVjdGlvbi5cbiAgICovXG4gIHN0YXRpYyBjb2xsZWN0aW9uQWRkKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS9hZGRcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbnVtYmVyIG9mIHJlY29yZHMgaW4gYSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgc3RhdGljIGNvbGxlY3Rpb25Db3VudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS9jb3VudFwiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIHJlY29yZHMgaW4gYSBjb2xsZWN0aW9uLiBDYW4gZmlsdGVyIGJ5IElEcyBvciBtZXRhZGF0YS5cbiAgICovXG4gIHN0YXRpYyBjb2xsZWN0aW9uRGVsZXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS9kZWxldGVcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZvcmtzIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb24uXG4gICAqL1xuICBzdGF0aWMgZm9ya0NvbGxlY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9L2ZvcmtcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyByZWNvcmRzIGZyb20gYSBjb2xsZWN0aW9uIGJ5IElEIG9yIG1ldGFkYXRhIGZpbHRlci5cbiAgICovXG4gIHN0YXRpYyBjb2xsZWN0aW9uR2V0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS9nZXRcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFF1ZXJ5IGEgY29sbGVjdGlvbiBpbiBhIHZhcmlldHkgb2Ygd2F5cywgaW5jbHVkaW5nIHZlY3RvciBzZWFyY2gsIG1ldGFkYXRhIGZpbHRlcmluZywgYW5kIGZ1bGwtdGV4dCBzZWFyY2hcbiAgICovXG4gIHN0YXRpYyBjb2xsZWN0aW9uUXVlcnkob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9L3F1ZXJ5XCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHJlY29yZHMgaW4gYSBjb2xsZWN0aW9uIGJ5IElELlxuICAgKi9cbiAgc3RhdGljIGNvbGxlY3Rpb25VcGRhdGUob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9L3VwZGF0ZVwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBzZXJ0cyByZWNvcmRzIGluIGEgY29sbGVjdGlvbiAoY3JlYXRlIGlmIG5vdCBleGlzdHMsIG90aGVyd2lzZSB1cGRhdGUpLlxuICAgKi9cbiAgc3RhdGljIGNvbGxlY3Rpb25VcHNlcnQob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9L3Vwc2VydFwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSB0b3RhbCBudW1iZXIgb2YgY29sbGVjdGlvbnMgaW4gYSBnaXZlbiBkYXRhYmFzZS5cbiAgICovXG4gIHN0YXRpYyBjb3VudENvbGxlY3Rpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnNfY291bnRcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGUgc2VydmVyLlxuICAgKi9cbiAgc3RhdGljIHZlcnNpb24ob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3ZlcnNpb25cIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy50c1xudmFyIENocm9tYUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbn07XG52YXIgQ2hyb21hQ29ubmVjdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiQ2hyb21hQ29ubmVjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgQ2hyb21hU2VydmVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJDaHJvbWFTZXJ2ZXJFcnJvclwiO1xuICB9XG59O1xudmFyIENocm9tYUNsaWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiQ2hyb21hQ2xpZW50RXJyb3JcIjtcbiAgfVxufTtcbnZhciBDaHJvbWFVbmF1dGhvcml6ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkNocm9tYUF1dGhFcnJvclwiO1xuICB9XG59O1xudmFyIENocm9tYUZvcmJpZGRlbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiQ2hyb21hRm9yYmlkZGVuRXJyb3JcIjtcbiAgfVxufTtcbnZhciBDaHJvbWFOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiQ2hyb21hTm90Rm91bmRFcnJvclwiO1xuICB9XG59O1xudmFyIENocm9tYVZhbHVlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJDaHJvbWFWYWx1ZUVycm9yXCI7XG4gIH1cbn07XG52YXIgSW52YWxpZENvbGxlY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkludmFsaWRDb2xsZWN0aW9uRXJyb3JcIjtcbiAgfVxufTtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkludmFsaWRBcmd1bWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgQ2hyb21hVW5pcXVlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJDaHJvbWFVbmlxdWVFcnJvclwiO1xuICB9XG59O1xudmFyIENocm9tYVF1b3RhRXhjZWVkZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkNocm9tYVF1b3RhRXhjZWVkZWRFcnJvclwiO1xuICB9XG59O1xudmFyIENocm9tYVJhdGVMaW1pdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiQ2hyb21hUmF0ZUxpbWl0RXJyb3JcIjtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUVycm9yQnlUeXBlKHR5cGUsIG1lc3NhZ2UpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIkludmFsaWRDb2xsZWN0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IEludmFsaWRDb2xsZWN0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgY2FzZSBcIkludmFsaWRBcmd1bWVudEVycm9yXCI6XG4gICAgICByZXR1cm4gbmV3IEludmFsaWRBcmd1bWVudEVycm9yKG1lc3NhZ2UpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy50c1xudmFyIERFRkFVTFRfVEVOQU5UID0gXCJkZWZhdWx0X3RlbmFudFwiO1xudmFyIERFRkFVTFRfREFUQUJBU0UgPSBcImRlZmF1bHRfZGF0YWJhc2VcIjtcbnZhciBkZWZhdWx0QWRtaW5DbGllbnRBcmdzID0ge1xuICBob3N0OiBcImxvY2FsaG9zdFwiLFxuICBwb3J0OiA4ZTMsXG4gIHNzbDogZmFsc2Vcbn07XG52YXIgZGVmYXVsdENocm9tYUNsaWVudEFyZ3MgPSB7XG4gIC4uLmRlZmF1bHRBZG1pbkNsaWVudEFyZ3MsXG4gIHRlbmFudDogREVGQVVMVF9URU5BTlQsXG4gIGRhdGFiYXNlOiBERUZBVUxUX0RBVEFCQVNFXG59O1xudmFyIG5vcm1hbGl6ZU1ldGhvZCA9IChtZXRob2QpID0+IHtcbiAgaWYgKG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJHRVRcIjpcbiAgICAgICAgcmV0dXJuIFwiR0VUXCI7XG4gICAgICBjYXNlIFwiUE9TVFwiOlxuICAgICAgICByZXR1cm4gXCJQT1NUXCI7XG4gICAgICBjYXNlIFwiUFVUXCI6XG4gICAgICAgIHJldHVybiBcIlBVVFwiO1xuICAgICAgY2FzZSBcIkRFTEVURVwiOlxuICAgICAgICByZXR1cm4gXCJERUxFVEVcIjtcbiAgICAgIGNhc2UgXCJIRUFEXCI6XG4gICAgICAgIHJldHVybiBcIkhFQURcIjtcbiAgICAgIGNhc2UgXCJDT05ORUNUXCI6XG4gICAgICAgIHJldHVybiBcIkNPTk5FQ1RcIjtcbiAgICAgIGNhc2UgXCJPUFRJT05TXCI6XG4gICAgICAgIHJldHVybiBcIk9QVElPTlNcIjtcbiAgICAgIGNhc2UgXCJQQVRDSFwiOlxuICAgICAgICByZXR1cm4gXCJQQVRDSFwiO1xuICAgICAgY2FzZSBcIlRSQUNFXCI6XG4gICAgICAgIHJldHVybiBcIlRSQUNFXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufTtcbnZhciB2YWxpZGF0ZVJlY29yZFNldExlbmd0aENvbnNpc3RlbmN5ID0gKHJlY29yZFNldCkgPT4ge1xuICBjb25zdCBsZW5ndGhzID0gT2JqZWN0LmVudHJpZXMocmVjb3JkU2V0KS5maWx0ZXIoXG4gICAgKFtmaWVsZCwgdmFsdWVdKSA9PiByZWNvcmRTZXRGaWVsZHMuaW5jbHVkZXMoZmllbGQpICYmIHZhbHVlICE9PSB2b2lkIDBcbiAgKS5tYXAoKFtmaWVsZCwgdmFsdWVdKSA9PiBbZmllbGQsIHZhbHVlLmxlbmd0aF0pO1xuICBpZiAobGVuZ3Rocy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBBdCBsZWFzdCBvbmUgb2YgJHtyZWNvcmRTZXRGaWVsZHMuam9pbihcIiwgXCIpfSBtdXN0IGJlIHByb3ZpZGVkYFxuICAgICk7XG4gIH1cbiAgY29uc3QgemVyb0xlbmd0aCA9IGxlbmd0aHMuZmlsdGVyKChbXzIsIGxlbmd0aF0pID0+IGxlbmd0aCA9PT0gMCkubWFwKChbZmllbGQsIF8yXSkgPT4gZmllbGQpO1xuICBpZiAoemVyb0xlbmd0aC5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgTm9uLWVtcHR5IGxpc3RzIGFyZSByZXF1aXJlZCBmb3IgJHt6ZXJvTGVuZ3RoLmpvaW4oXCIsIFwiKX1gXG4gICAgKTtcbiAgfVxuICBpZiAobmV3IFNldChsZW5ndGhzLm1hcCgoW18yLCBsZW5ndGhdKSA9PiBsZW5ndGgpKS5zaXplID4gMSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYFVuZXF1YWwgbGVuZ3RocyBmb3IgZmllbGRzICR7bGVuZ3Rocy5tYXAoKFtmaWVsZCwgXzJdKSA9PiBmaWVsZCkuam9pbihcIiwgXCIpfWBcbiAgICApO1xuICB9XG59O1xudmFyIHZhbGlkYXRlRW1iZWRkaW5ncyA9ICh7XG4gIGVtYmVkZGluZ3MsXG4gIGZpZWxkTmFtZSA9IFwiZW1iZWRkaW5nc1wiXG59KSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShlbWJlZGRpbmdzKSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICcke2ZpZWxkTmFtZX0nIHRvIGJlIGFuIGFycmF5LCBidXQgZ290ICR7dHlwZW9mIGVtYmVkZGluZ3N9YFxuICAgICk7XG4gIH1cbiAgaWYgKGVtYmVkZGluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGVtYmVkZGluZ3MgdG8gYmUgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgaXRlbVwiXG4gICAgKTtcbiAgfVxuICBpZiAoIWVtYmVkZGluZ3MuZmlsdGVyKChlKSA9PiBlLmV2ZXJ5KChuKSA9PiB0eXBlb2YgbiA9PT0gXCJudW1iZXJcIikpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGVhY2ggZW1iZWRkaW5nIHRvIGJlIGFuIGFycmF5IG9mIG51bWJlcnNcIlxuICAgICk7XG4gIH1cbiAgZW1iZWRkaW5ncy5mb3JFYWNoKChlbWJlZGRpbmcsIGkpID0+IHtcbiAgICBpZiAoZW1iZWRkaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBlYWNoIGVtYmVkZGluZyB0byBiZSBhIG5vbi1lbXB0eSBhcnJheSBvZiBudW1iZXJzLCBidXQgZ290IGFuIGVtcHR5IGFycmF5IGF0IGluZGV4ICR7aX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlRG9jdW1lbnRzID0gKHtcbiAgZG9jdW1lbnRzLFxuICBudWxsYWJsZSA9IGZhbHNlLFxuICBmaWVsZE5hbWUgPSBcImRvY3VtZW50c1wiXG59KSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkb2N1bWVudHMpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgJyR7ZmllbGROYW1lfScgdG8gYmUgYW4gYXJyYXksIGJ1dCBnb3QgJHt0eXBlb2YgZG9jdW1lbnRzfWBcbiAgICApO1xuICB9XG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgJyR7ZmllbGROYW1lfScgdG8gYmUgYSBub24tZW1wdHkgbGlzdGBcbiAgICApO1xuICB9XG4gIGRvY3VtZW50cy5mb3JFYWNoKChkb2N1bWVudCkgPT4ge1xuICAgIGlmICghbnVsbGFibGUgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInN0cmluZ1wiICYmICFkb2N1bWVudCkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBlYWNoIGRvY3VtZW50IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7dHlwZW9mIGRvY3VtZW50fWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgdmFsaWRhdGVJRHMgPSAoaWRzKSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpZHMpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgJ2lkcycgdG8gYmUgYW4gYXJyYXksIGJ1dCBnb3QgJHt0eXBlb2YgaWRzfWBcbiAgICApO1xuICB9XG4gIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXCJFeHBlY3RlZCAnaWRzJyB0byBiZSBhIG5vbi1lbXB0eSBsaXN0XCIpO1xuICB9XG4gIGNvbnN0IG5vblN0cmluZ3MgPSBpZHMubWFwKChpZCwgaSkgPT4gW2lkLCBpXSkuZmlsdGVyKChbaWQsIF8yXSkgPT4gdHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKS5tYXAoKFtfMiwgaV0pID0+IGkpO1xuICBpZiAobm9uU3RyaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRm91bmQgbm9uLXN0cmluZyBJRHMgYXQgJHtub25TdHJpbmdzLmpvaW4oXCIsIFwiKX1gXG4gICAgKTtcbiAgfVxuICBjb25zdCBzZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgZHVwbGljYXRlcyA9IGlkcy5maWx0ZXIoKGlkKSA9PiB7XG4gICAgaWYgKHNlZW4uaGFzKGlkKSkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBzZWVuLmFkZChpZCk7XG4gIH0pO1xuICBsZXQgbWVzc2FnZSA9IFwiRXhwZWN0ZWQgSURzIHRvIGJlIHVuaXF1ZSwgYnV0IGZvdW5kIGR1cGxpY2F0ZXMgb2ZcIjtcbiAgaWYgKGR1cGxpY2F0ZXMubGVuZ3RoID4gMCAmJiBkdXBsaWNhdGVzLmxlbmd0aCA8PSA1KSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoYCR7bWVzc2FnZX0gJHtkdXBsaWNhdGVzLmpvaW4oXCIsIFwiKX1gKTtcbiAgfVxuICBpZiAoZHVwbGljYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgJHttZXNzYWdlfSAke2R1cGxpY2F0ZXMuc2xpY2UoMCwgNSkuam9pbihcIiwgXCIpfSwgLi4uLCAke2R1cGxpY2F0ZXMuc2xpY2UoZHVwbGljYXRlcy5sZW5ndGggLSA1KS5qb2luKFwiLCBcIil9YFxuICAgICk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVNZXRhZGF0YSA9IChtZXRhZGF0YSkgPT4ge1xuICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyhtZXRhZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXCJFeHBlY3RlZCBtZXRhZGF0YSB0byBiZSBub24tZW1wdHlcIik7XG4gIH1cbiAgaWYgKCFPYmplY3QudmFsdWVzKG1ldGFkYXRhKS5ldmVyeShcbiAgICAodikgPT4gdiA9PT0gbnVsbCB8fCB2ID09PSB2b2lkIDAgfHwgdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHYgPT09IFwiYm9vbGVhblwiXG4gICkpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgbWV0YWRhdGEgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbGFibGVcIlxuICAgICk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVNZXRhZGF0YXMgPSAobWV0YWRhdGFzKSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShtZXRhZGF0YXMpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgbWV0YWRhdGFzIHRvIGJlIGFuIGFycmF5LCBidXQgZ290ICR7dHlwZW9mIG1ldGFkYXRhc31gXG4gICAgKTtcbiAgfVxuICBtZXRhZGF0YXMuZm9yRWFjaCgobWV0YWRhdGEpID0+IHZhbGlkYXRlTWV0YWRhdGEobWV0YWRhdGEpKTtcbn07XG52YXIgdmFsaWRhdGVCYXNlUmVjb3JkU2V0ID0gKHtcbiAgcmVjb3JkU2V0LFxuICB1cGRhdGUgPSBmYWxzZSxcbiAgZW1iZWRkaW5nc0ZpZWxkID0gXCJlbWJlZGRpbmdzXCIsXG4gIGRvY3VtZW50c0ZpZWxkID0gXCJkb2N1bWVudHNcIlxufSkgPT4ge1xuICBpZiAoIXJlY29yZFNldC5lbWJlZGRpbmdzICYmICFyZWNvcmRTZXQuZG9jdW1lbnRzICYmICF1cGRhdGUpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBBdCBsZWFzdCBvbmUgb2YgJyR7ZW1iZWRkaW5nc0ZpZWxkfScgYW5kICcke2RvY3VtZW50c0ZpZWxkfScgbXVzdCBiZSBwcm92aWRlZGBcbiAgICApO1xuICB9XG4gIGlmIChyZWNvcmRTZXQuZW1iZWRkaW5ncykge1xuICAgIHZhbGlkYXRlRW1iZWRkaW5ncyh7XG4gICAgICBlbWJlZGRpbmdzOiByZWNvcmRTZXQuZW1iZWRkaW5ncyxcbiAgICAgIGZpZWxkTmFtZTogZW1iZWRkaW5nc0ZpZWxkXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlY29yZFNldC5kb2N1bWVudHMpIHtcbiAgICB2YWxpZGF0ZURvY3VtZW50cyh7XG4gICAgICBkb2N1bWVudHM6IHJlY29yZFNldC5kb2N1bWVudHMsXG4gICAgICBmaWVsZE5hbWU6IGRvY3VtZW50c0ZpZWxkXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlY29yZFNldC5tZXRhZGF0YXMpIHtcbiAgICB2YWxpZGF0ZU1ldGFkYXRhcyhyZWNvcmRTZXQubWV0YWRhdGFzKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZU1heEJhdGNoU2l6ZSA9IChyZWNvcmRTZXRMZW5ndGgsIG1heEJhdGNoU2l6ZSkgPT4ge1xuICBpZiAocmVjb3JkU2V0TGVuZ3RoID4gbWF4QmF0Y2hTaXplKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgUmVjb3JkIHNldCBsZW5ndGggJHtyZWNvcmRTZXRMZW5ndGh9IGV4Y2VlZHMgbWF4IGJhdGNoIHNpemUgJHttYXhCYXRjaFNpemV9YFxuICAgICk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVXaGVyZSA9ICh3aGVyZSkgPT4ge1xuICBpZiAodHlwZW9mIHdoZXJlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXCJFeHBlY3RlZCB3aGVyZSB0byBiZSBhIG5vbi1lbXB0eSBvYmplY3RcIik7XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHdoZXJlKS5sZW5ndGggIT0gMSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICd3aGVyZScgdG8gaGF2ZSBleGFjdGx5IG9uZSBvcGVyYXRvciwgYnV0IGdvdCAke09iamVjdC5rZXlzKHdoZXJlKS5sZW5ndGh9YFxuICAgICk7XG4gIH1cbiAgT2JqZWN0LmVudHJpZXMod2hlcmUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChrZXkgIT09IFwiJGFuZFwiICYmIGtleSAhPT0gXCIkb3JcIiAmJiBrZXkgIT09IFwiJGluXCIgJiYga2V5ICE9PSBcIiRuaW5cIiAmJiAhW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiLCBcIm9iamVjdFwiXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkICd3aGVyZScgdmFsdWUgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgYW4gb3BlcmF0b3IgZXhwcmVzc2lvbiwgYnV0IGdvdCAke3ZhbHVlfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwiJGFuZFwiIHx8IGtleSA9PT0gXCIkb3JcIikge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPD0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgJ3doZXJlJyB2YWx1ZSBmb3IgJGFuZCBvciAkb3IgdG8gYmUgYSBsaXN0IG9mICd3aGVyZScgZXhwcmVzc2lvbnMsIGJ1dCBnb3QgJHt2YWx1ZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YWx1ZS5mb3JFYWNoKCh3MikgPT4gdmFsaWRhdGVXaGVyZSh3MikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBvcGVyYXRvciBleHByZXNzaW9uIHRvIGhhdmUgb25lIG9wZXJhdG9yLCBidXQgZ290ICR7dmFsdWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgW29wZXJhdG9yLCBvcGVyYW5kXSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKVswXTtcbiAgICAgIGlmIChbXCIkZ3RcIiwgXCIkZ3RlXCIsIFwiJGx0XCIsIFwiJGx0ZVwiXS5pbmNsdWRlcyhvcGVyYXRvcikgJiYgdHlwZW9mIG9wZXJhbmQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIG9wZXJhbmQgdmFsdWUgdG8gYmUgYSBudW1iZXIgZm9yICR7b3BlcmF0b3J9LCBidXQgZ290ICR7dHlwZW9mIG9wZXJhbmR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFtcIiRpblwiLCBcIiRuaW5cIl0uaW5jbHVkZXMob3BlcmF0b3IpICYmICFBcnJheS5pc0FycmF5KG9wZXJhbmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBvcGVyYW5kIHZhbHVlIHRvIGJlIGFuIGFycmF5IGZvciAke29wZXJhdG9yfSwgYnV0IGdvdCAke29wZXJhbmR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFbXCIkZ3RcIiwgXCIkZ3RlXCIsIFwiJGx0XCIsIFwiJGx0ZVwiLCBcIiRuZVwiLCBcIiRlcVwiLCBcIiRpblwiLCBcIiRuaW5cIl0uaW5jbHVkZXMoXG4gICAgICAgIG9wZXJhdG9yXG4gICAgICApKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBvcGVyYXRvciB0byBiZSBvbmUgb2YgJGd0LCAkZ3RlLCAkbHQsICRsdGUsICRuZSwgJGVxLCAkaW4sICRuaW4sIGJ1dCBnb3QgJHtvcGVyYXRvcn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIVtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZW9mIG9wZXJhbmQpICYmICFBcnJheS5pc0FycmF5KG9wZXJhbmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgb3BlcmFuZCB2YWx1ZSB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBhIGxpc3Qgb2YgdGhvc2UgdHlwZXNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3BlcmFuZCkgJiYgKG9wZXJhbmQubGVuZ3RoID09PSAwIHx8ICFvcGVyYW5kLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gdHlwZW9mIG9wZXJhbmRbMF0pKSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkICd3aGVyZScgb3BlcmFuZCB2YWx1ZSB0byBiZSBhIG5vbi1lbXB0eSBsaXN0IGFuZCBhbGwgdmFsdWVzIHRvIGJlIG9mIHRoZSBzYW1lIHR5cGVcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlV2hlcmVEb2N1bWVudCA9ICh3aGVyZURvY3VtZW50KSA9PiB7XG4gIGlmICh0eXBlb2Ygd2hlcmVEb2N1bWVudCAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCAnd2hlcmVEb2N1bWVudCcgdG8gYmUgYSBub24tZW1wdHkgb2JqZWN0XCJcbiAgICApO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyh3aGVyZURvY3VtZW50KS5sZW5ndGggIT0gMSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICd3aGVyZURvY3VtZW50JyB0byBoYXZlIGV4YWN0bHkgb25lIG9wZXJhdG9yLCBidXQgZ290ICR7d2hlcmVEb2N1bWVudH1gXG4gICAgKTtcbiAgfVxuICBjb25zdCBbb3BlcmF0b3IsIG9wZXJhbmRdID0gT2JqZWN0LmVudHJpZXMod2hlcmVEb2N1bWVudClbMF07XG4gIGlmICghW1xuICAgIFwiJGNvbnRhaW5zXCIsXG4gICAgXCIkbm90X2NvbnRhaW5zXCIsXG4gICAgXCIkbWF0Y2hlc1wiLFxuICAgIFwiJG5vdF9tYXRjaGVzXCIsXG4gICAgXCIkcmVnZXhcIixcbiAgICBcIiRub3RfcmVnZXhcIixcbiAgICBcIiRhbmRcIixcbiAgICBcIiRvclwiXG4gIF0uaW5jbHVkZXMob3BlcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgJ3doZXJlRG9jdW1lbnQnIG9wZXJhdG9yIHRvIGJlIG9uZSBvZiAkY29udGFpbnMsICRub3RfY29udGFpbnMsICRtYXRjaGVzLCAkbm90X21hdGNoZXMsICRyZWdleCwgJG5vdF9yZWdleCwgJGFuZCwgb3IgJG9yLCBidXQgZ290ICR7b3BlcmF0b3J9YFxuICAgICk7XG4gIH1cbiAgaWYgKG9wZXJhdG9yID09PSBcIiRhbmRcIiB8fCBvcGVyYXRvciA9PT0gXCIkb3JcIikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcGVyYW5kKSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBvcGVyYW5kIGZvciAke29wZXJhdG9yfSB0byBiZSBhIGxpc3Qgb2YgJ3doZXJlRG9jdW1lbnQnIGV4cHJlc3Npb25zLCBidXQgZ290ICR7b3BlcmFuZH1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3BlcmFuZC5sZW5ndGggPD0gMSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCAnd2hlcmVEb2N1bWVudCcgb3BlcmFuZCBmb3IgJHtvcGVyYXRvcn0gdG8gYmUgYSBsaXN0IHdpdGggYXQgbGVhc3QgdHdvICd3aGVyZURvY3VtZW50JyBleHByZXNzaW9uc2BcbiAgICAgICk7XG4gICAgfVxuICAgIG9wZXJhbmQuZm9yRWFjaCgoaXRlbSkgPT4gdmFsaWRhdGVXaGVyZURvY3VtZW50KGl0ZW0pKTtcbiAgfVxuICBpZiAoKG9wZXJhbmQgPT09IFwiJGNvbnRhaW5zXCIgfHwgb3BlcmFuZCA9PT0gXCIkbm90X2NvbnRhaW5zXCIgfHwgb3BlcmFuZCA9PT0gXCIkcmVnZXhcIiB8fCBvcGVyYW5kID09PSBcIiRub3RfcmVnZXhcIikgJiYgKHR5cGVvZiBvcGVyYXRvciAhPT0gXCJzdHJpbmdcIiB8fCBvcGVyYXRvci5sZW5ndGggPT09IDApKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgb3BlcmFuZCBmb3IgJHtvcGVyYXRvcn0gdG8gYmUgYSBub24gZW1wdHkgc3RyaW5nLCBidXQgZ290ICR7b3BlcmFuZH1gXG4gICAgKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZUluY2x1ZGUgPSAoe1xuICBpbmNsdWRlLFxuICBleGNsdWRlXG59KSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbmNsdWRlKSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgJ2luY2x1ZGUnIHRvIGJlIGEgbm9uLWVtcHR5IGFycmF5XCIpO1xuICB9XG4gIGNvbnN0IHZhbGlkVmFsdWVzID0gT2JqZWN0LmtleXMoSW5jbHVkZUVudW0pO1xuICBpbmNsdWRlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgJ2luY2x1ZGUnIGl0ZW1zIHRvIGJlIHN0cmluZ3NcIik7XG4gICAgfVxuICAgIGlmICghdmFsaWRWYWx1ZXMuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgJ2luY2x1ZGUnIGl0ZW1zIHRvIGJlIG9uZSBvZiAke3ZhbGlkVmFsdWVzLmpvaW4oXG4gICAgICAgICAgXCIsIFwiXG4gICAgICAgICl9LCBidXQgZ290ICR7aXRlbX1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZXhjbHVkZT8uaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKGAke2l0ZW19IGlzIG5vdCBhbGxvd2VkIGZvciB0aGlzIG9wZXJhdGlvbmApO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlTlJlc3VsdHMgPSAoblJlc3VsdHMpID0+IHtcbiAgaWYgKHR5cGVvZiBuUmVzdWx0cyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICduUmVzdWx0cycgdG8gYmUgYSBudW1iZXIsIGJ1dCBnb3QgJHt0eXBlb2YgblJlc3VsdHN9YFxuICAgICk7XG4gIH1cbiAgaWYgKG5SZXN1bHRzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcIk51bWJlciBvZiByZXF1ZXN0ZWQgcmVzdWx0cyBoYXMgdG8gcG9zaXRpdmVcIik7XG4gIH1cbn07XG52YXIgcGFyc2VDb25uZWN0aW9uUGF0aCA9IChwYXRoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoKTtcbiAgICBjb25zdCBzc2wgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgY29uc3QgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNzbCxcbiAgICAgIGhvc3QsXG4gICAgICBwb3J0OiBOdW1iZXIocG9ydClcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihgSW52YWxpZCBVUkw6ICR7cGF0aH1gKTtcbiAgfVxufTtcbnZhciBwYWNrRW1iZWRkaW5nID0gKGVtYmVkZGluZykgPT4ge1xuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZW1iZWRkaW5nLmxlbmd0aCAqIDQpO1xuICBjb25zdCB2aWV3ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVtYmVkZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHZpZXdbaV0gPSBlbWJlZGRpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG52YXIgZW1iZWRkaW5nc1RvQmFzZTY0Qnl0ZXMgPSAoZW1iZWRkaW5ncykgPT4ge1xuICByZXR1cm4gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZykgPT4ge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHBhY2tFbWJlZGRpbmcoZW1iZWRkaW5nKTtcbiAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBBcnJheS5mcm9tKFxuICAgICAgdWludDhBcnJheSxcbiAgICAgIChieXRlKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpXG4gICAgKS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBidG9hKGJpbmFyeVN0cmluZyk7XG4gIH0pO1xufTtcblxuLy8gc3JjL2VtYmVkZGluZy1mdW5jdGlvbi50c1xudmFyIGtub3duRW1iZWRkaW5nRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciByZWdpc3RlckVtYmVkZGluZ0Z1bmN0aW9uID0gKG5hbWUsIGZuKSA9PiB7XG4gIGlmIChrbm93bkVtYmVkZGluZ0Z1bmN0aW9ucy5oYXMobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBFbWJlZGRpbmcgZnVuY3Rpb24gd2l0aCBuYW1lICR7bmFtZX0gaXMgYWxyZWFkeSByZWdpc3RlcmVkLmBcbiAgICApO1xuICB9XG4gIGtub3duRW1iZWRkaW5nRnVuY3Rpb25zLnNldChuYW1lLCBmbik7XG59O1xudmFyIGdldEVtYmVkZGluZ0Z1bmN0aW9uID0gYXN5bmMgKGNvbGxlY3Rpb25OYW1lLCBlZkNvbmZpZykgPT4ge1xuICBpZiAoIWVmQ29uZmlnKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYE5vIGVtYmVkZGluZyBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGZvdW5kIGZvciBjb2xsZWN0aW9uICR7Y29sbGVjdGlvbk5hbWV9LiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChlZkNvbmZpZy50eXBlID09PSBcImxlZ2FjeVwiKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYE5vIGVtYmVkZGluZyBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGZvdW5kIGZvciBjb2xsZWN0aW9uICR7Y29sbGVjdGlvbk5hbWV9LiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IG5hbWUgPSBlZkNvbmZpZy5uYW1lO1xuICBjb25zdCBlbWJlZGRpbmdGdW5jdGlvbiA9IGtub3duRW1iZWRkaW5nRnVuY3Rpb25zLmdldChuYW1lKTtcbiAgaWYgKCFlbWJlZGRpbmdGdW5jdGlvbikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBDb2xsZWN0aW9uICR7Y29sbGVjdGlvbk5hbWV9IHdhcyBjcmVhdGVkIHdpdGggdGhlICR7ZW1iZWRkaW5nRnVuY3Rpb259IGVtYmVkZGluZyBmdW5jdGlvbi4gSG93ZXZlciwgdGhlIEBjaHJvbWEtY29yZS8ke2VtYmVkZGluZ0Z1bmN0aW9ufSBwYWNrYWdlIGlzIG5vdCBpbnN0YWxsLiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseSwgb3IgaW5zdGFsbCB0aGUgQGNocm9tYS1jb3JlLyR7ZW1iZWRkaW5nRnVuY3Rpb259IHBhY2thZ2UuYFxuICAgICk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgY29uc3RydWN0b3JDb25maWcgPSBlZkNvbmZpZy50eXBlID09PSBcImtub3duXCIgPyBlZkNvbmZpZy5jb25maWcgOiB7fTtcbiAgdHJ5IHtcbiAgICBpZiAoZW1iZWRkaW5nRnVuY3Rpb24uYnVpbGRGcm9tQ29uZmlnKSB7XG4gICAgICByZXR1cm4gZW1iZWRkaW5nRnVuY3Rpb24uYnVpbGRGcm9tQ29uZmlnKGNvbnN0cnVjdG9yQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEVtYmVkZGluZyBmdW5jdGlvbiAke25hbWV9IGRvZXMgbm90IGRlZmluZSBhICdidWlsZEZyb21Db25maWcnIGZ1bmN0aW9uLiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEVtYmVkZGluZyBmdW5jdGlvbiAke25hbWV9IGZhaWxlZCB0byBidWlsZCB3aXRoIGNvbmZpZzogJHtjb25zdHJ1Y3RvckNvbmZpZ30uICdhZGQnIGFuZCAncXVlcnknIHdpbGwgZmFpbCB1bmxlc3MgeW91IHByb3ZpZGUgdGhlbSBlbWJlZGRpbmdzIGRpcmVjdGx5LiBFcnJvcjogJHtlfWBcbiAgICApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG52YXIgc2VyaWFsaXplRW1iZWRkaW5nRnVuY3Rpb24gPSAoe1xuICBlbWJlZGRpbmdGdW5jdGlvbixcbiAgY29uZmlnRW1iZWRkaW5nRnVuY3Rpb25cbn0pID0+IHtcbiAgaWYgKGVtYmVkZGluZ0Z1bmN0aW9uICYmIGNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkVtYmVkZGluZyBmdW5jdGlvbiBwcm92aWRlZCB3aGVuIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgY29sbGVjdGlvbiBjb25maWd1cmF0aW9uXCJcbiAgICApO1xuICB9XG4gIGlmICghZW1iZWRkaW5nRnVuY3Rpb24gJiYgIWNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBlZiA9IGVtYmVkZGluZ0Z1bmN0aW9uIHx8IGNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uO1xuICBpZiAoIWVmLmdldENvbmZpZyB8fCAhZWYubmFtZSB8fCAhZWYuY29uc3RydWN0b3IuYnVpbGRGcm9tQ29uZmlnKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJsZWdhY3lcIiB9O1xuICB9XG4gIGlmIChlZi52YWxpZGF0ZUNvbmZpZykgZWYudmFsaWRhdGVDb25maWcoZWYuZ2V0Q29uZmlnKCkpO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IGVmLm5hbWUsXG4gICAgdHlwZTogXCJrbm93blwiLFxuICAgIGNvbmZpZzogZWYuZ2V0Q29uZmlnKClcbiAgfTtcbn07XG52YXIgZ2V0RGVmYXVsdEVGQ29uZmlnID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgRGVmYXVsdEVtYmVkZGluZ0Z1bmN0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXCJAY2hyb21hLWNvcmUvZGVmYXVsdC1lbWJlZFwiKTtcbiAgICBpZiAoIWtub3duRW1iZWRkaW5nRnVuY3Rpb25zLmhhcyhuZXcgRGVmYXVsdEVtYmVkZGluZ0Z1bmN0aW9uKCkubmFtZSkpIHtcbiAgICAgIHJlZ2lzdGVyRW1iZWRkaW5nRnVuY3Rpb24oXCJkZWZhdWx0XCIsIERlZmF1bHRFbWJlZGRpbmdGdW5jdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNhbm5vdCBpbnN0YW50aWF0ZSBhIGNvbGxlY3Rpb24gd2l0aCB0aGUgRGVmYXVsdEVtYmVkZGluZ0Z1bmN0aW9uLiBQbGVhc2UgaW5zdGFsbCBAY2hyb21hLWNvcmUvZGVmYXVsdC1lbWJlZCwgb3IgcHJvdmlkZSBhIGRpZmZlcmVudCBlbWJlZGRpbmcgZnVuY3Rpb25cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcImRlZmF1bHRcIixcbiAgICB0eXBlOiBcImtub3duXCIsXG4gICAgY29uZmlnOiB7fVxuICB9O1xufTtcblxuLy8gc3JjL2NvbGxlY3Rpb24tY29uZmlndXJhdGlvbi50c1xudmFyIHByb2Nlc3NDcmVhdGVDb2xsZWN0aW9uQ29uZmlnID0gYXN5bmMgKHtcbiAgY29uZmlndXJhdGlvbixcbiAgZW1iZWRkaW5nRnVuY3Rpb25cbn0pID0+IHtcbiAgaWYgKGNvbmZpZ3VyYXRpb24/Lmhuc3cgJiYgY29uZmlndXJhdGlvbj8uc3Bhbm4pIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYm90aCBITlNXIGFuZCBTUEFOTiBjb25maWd1cmF0aW9uc1wiXG4gICAgKTtcbiAgfVxuICBsZXQgZW1iZWRkaW5nRnVuY3Rpb25Db25maWd1cmF0aW9uID0gc2VyaWFsaXplRW1iZWRkaW5nRnVuY3Rpb24oe1xuICAgIGVtYmVkZGluZ0Z1bmN0aW9uOiBlbWJlZGRpbmdGdW5jdGlvbiA/PyB2b2lkIDAsXG4gICAgY29uZmlnRW1iZWRkaW5nRnVuY3Rpb246IGNvbmZpZ3VyYXRpb24/LmVtYmVkZGluZ0Z1bmN0aW9uXG4gIH0pO1xuICBpZiAoIWVtYmVkZGluZ0Z1bmN0aW9uQ29uZmlndXJhdGlvbiAmJiBlbWJlZGRpbmdGdW5jdGlvbiAhPT0gbnVsbCkge1xuICAgIGVtYmVkZGluZ0Z1bmN0aW9uQ29uZmlndXJhdGlvbiA9IGF3YWl0IGdldERlZmF1bHRFRkNvbmZpZygpO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uY29uZmlndXJhdGlvbiB8fCB7fSxcbiAgICBlbWJlZGRpbmdfZnVuY3Rpb246IGVtYmVkZGluZ0Z1bmN0aW9uQ29uZmlndXJhdGlvblxuICB9O1xufTtcbnZhciBwcm9jZXNzVXBkYXRlQ29sbGVjdGlvbkNvbmZpZyA9IGFzeW5jICh7XG4gIGNvbGxlY3Rpb25OYW1lLFxuICBjdXJyZW50Q29uZmlndXJhdGlvbixcbiAgY3VycmVudEVtYmVkZGluZ0Z1bmN0aW9uLFxuICBuZXdDb25maWd1cmF0aW9uXG59KSA9PiB7XG4gIGlmIChuZXdDb25maWd1cmF0aW9uLmhuc3cgJiYgdHlwZW9mIG5ld0NvbmZpZ3VyYXRpb24uaG5zdyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgXCJJbnZhbGlkIEhOU1cgY29uZmlnIHByb3ZpZGVkIGluIFVwZGF0ZUNvbGxlY3Rpb25Db25maWd1cmF0aW9uXCJcbiAgICApO1xuICB9XG4gIGlmIChuZXdDb25maWd1cmF0aW9uLnNwYW5uICYmIHR5cGVvZiBuZXdDb25maWd1cmF0aW9uLnNwYW5uICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkludmFsaWQgU1BBTk4gY29uZmlnIHByb3ZpZGVkIGluIFVwZGF0ZUNvbGxlY3Rpb25Db25maWd1cmF0aW9uXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IGVtYmVkZGluZ0Z1bmN0aW9uID0gY3VycmVudEVtYmVkZGluZ0Z1bmN0aW9uIHx8IGF3YWl0IGdldEVtYmVkZGluZ0Z1bmN0aW9uKFxuICAgIGNvbGxlY3Rpb25OYW1lLFxuICAgIGN1cnJlbnRDb25maWd1cmF0aW9uLmVtYmVkZGluZ0Z1bmN0aW9uID8/IHZvaWQgMFxuICApO1xuICBjb25zdCBuZXdFbWJlZGRpbmdGdW5jdGlvbiA9IG5ld0NvbmZpZ3VyYXRpb24uZW1iZWRkaW5nRnVuY3Rpb247XG4gIGlmIChlbWJlZGRpbmdGdW5jdGlvbiAmJiBlbWJlZGRpbmdGdW5jdGlvbi52YWxpZGF0ZUNvbmZpZ1VwZGF0ZSAmJiBuZXdFbWJlZGRpbmdGdW5jdGlvbiAmJiBuZXdFbWJlZGRpbmdGdW5jdGlvbi5nZXRDb25maWcpIHtcbiAgICBlbWJlZGRpbmdGdW5jdGlvbi52YWxpZGF0ZUNvbmZpZ1VwZGF0ZShuZXdFbWJlZGRpbmdGdW5jdGlvbi5nZXRDb25maWcoKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGVDb25maWd1cmF0aW9uOiB7XG4gICAgICBobnN3OiBuZXdDb25maWd1cmF0aW9uLmhuc3csXG4gICAgICBzcGFubjogbmV3Q29uZmlndXJhdGlvbi5zcGFubixcbiAgICAgIGVtYmVkZGluZ19mdW5jdGlvbjogbmV3RW1iZWRkaW5nRnVuY3Rpb24gJiYgc2VyaWFsaXplRW1iZWRkaW5nRnVuY3Rpb24oeyBlbWJlZGRpbmdGdW5jdGlvbjogbmV3RW1iZWRkaW5nRnVuY3Rpb24gfSlcbiAgICB9LFxuICAgIHVwZGF0ZUVtYmVkZGluZ0Z1bmN0aW9uOiBuZXdFbWJlZGRpbmdGdW5jdGlvblxuICB9O1xufTtcblxuLy8gc3JjL2NvbGxlY3Rpb24udHNcbnZhciBDb2xsZWN0aW9uSW1wbCA9IGNsYXNzIF9Db2xsZWN0aW9uSW1wbCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENvbGxlY3Rpb25BUElJbXBsIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBjb2xsZWN0aW9uIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGNocm9tYUNsaWVudCxcbiAgICBhcGlDbGllbnQsXG4gICAgaWQsXG4gICAgbmFtZSxcbiAgICBtZXRhZGF0YSxcbiAgICBjb25maWd1cmF0aW9uLFxuICAgIGVtYmVkZGluZ0Z1bmN0aW9uXG4gIH0pIHtcbiAgICB0aGlzLmNocm9tYUNsaWVudCA9IGNocm9tYUNsaWVudDtcbiAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fbWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB0aGlzLl9jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICB0aGlzLl9lbWJlZGRpbmdGdW5jdGlvbiA9IGVtYmVkZGluZ0Z1bmN0aW9uO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG4gIHNldCBuYW1lKG5hbWUpIHtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgfVxuICBnZXQgY29uZmlndXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlndXJhdGlvbjtcbiAgfVxuICBzZXQgY29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKSB7XG4gICAgdGhpcy5fY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gIH1cbiAgZ2V0IG1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YTtcbiAgfVxuICBzZXQgbWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICB0aGlzLl9tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICB9XG4gIGdldCBlbWJlZGRpbmdGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1iZWRkaW5nRnVuY3Rpb247XG4gIH1cbiAgc2V0IGVtYmVkZGluZ0Z1bmN0aW9uKGVtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgdGhpcy5fZW1iZWRkaW5nRnVuY3Rpb24gPSBlbWJlZGRpbmdGdW5jdGlvbjtcbiAgfVxuICBhc3luYyBwYXRoKCkge1xuICAgIGNvbnN0IGNsaWVudFBhdGggPSBhd2FpdCB0aGlzLmNocm9tYUNsaWVudC5fcGF0aCgpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jbGllbnRQYXRoLFxuICAgICAgY29sbGVjdGlvbl9pZDogdGhpcy5pZFxuICAgIH07XG4gIH1cbiAgYXN5bmMgZW1iZWQoZG9jdW1lbnRzKSB7XG4gICAgaWYgKCF0aGlzLl9lbWJlZGRpbmdGdW5jdGlvbikge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIFwiRW1iZWRkaW5nIGZ1bmN0aW9uIG11c3QgYmUgZGVmaW5lZCBmb3Igb3BlcmF0aW9ucyByZXF1aXJpbmcgZW1iZWRkaW5ncy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2VtYmVkZGluZ0Z1bmN0aW9uLmdlbmVyYXRlKGRvY3VtZW50cyk7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZVJlY29yZHMoe1xuICAgIHJlY29yZFNldCxcbiAgICB1cGRhdGUgPSBmYWxzZVxuICB9KSB7XG4gICAgY29uc3QgbWF4QmF0Y2hTaXplID0gYXdhaXQgdGhpcy5jaHJvbWFDbGllbnQuZ2V0TWF4QmF0Y2hTaXplKCk7XG4gICAgdmFsaWRhdGVSZWNvcmRTZXRMZW5ndGhDb25zaXN0ZW5jeShyZWNvcmRTZXQpO1xuICAgIHZhbGlkYXRlSURzKHJlY29yZFNldC5pZHMpO1xuICAgIHZhbGlkYXRlQmFzZVJlY29yZFNldCh7IHJlY29yZFNldCwgdXBkYXRlIH0pO1xuICAgIHZhbGlkYXRlTWF4QmF0Y2hTaXplKHJlY29yZFNldC5pZHMubGVuZ3RoLCBtYXhCYXRjaFNpemUpO1xuICAgIGlmICghcmVjb3JkU2V0LmVtYmVkZGluZ3MgJiYgcmVjb3JkU2V0LmRvY3VtZW50cykge1xuICAgICAgcmVjb3JkU2V0LmVtYmVkZGluZ3MgPSBhd2FpdCB0aGlzLmVtYmVkKHJlY29yZFNldC5kb2N1bWVudHMpO1xuICAgIH1cbiAgICBjb25zdCBwcmVwYXJlZFJlY29yZFNldCA9IHsgLi4ucmVjb3JkU2V0IH07XG4gICAgY29uc3QgYmFzZTY0U3VwcG9ydGVkID0gYXdhaXQgdGhpcy5jaHJvbWFDbGllbnQuc3VwcG9ydHNCYXNlNjRFbmNvZGluZygpO1xuICAgIGlmIChiYXNlNjRTdXBwb3J0ZWQgJiYgcmVjb3JkU2V0LmVtYmVkZGluZ3MpIHtcbiAgICAgIHByZXBhcmVkUmVjb3JkU2V0LmVtYmVkZGluZ3MgPSBlbWJlZGRpbmdzVG9CYXNlNjRCeXRlcyhcbiAgICAgICAgcmVjb3JkU2V0LmVtYmVkZGluZ3NcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwcmVwYXJlZFJlY29yZFNldDtcbiAgfVxuICB2YWxpZGF0ZUdldChpbmNsdWRlLCBpZHMsIHdoZXJlLCB3aGVyZURvY3VtZW50KSB7XG4gICAgdmFsaWRhdGVJbmNsdWRlKHsgaW5jbHVkZSwgZXhjbHVkZTogW1wiZGlzdGFuY2VzXCJdIH0pO1xuICAgIGlmIChpZHMpIHZhbGlkYXRlSURzKGlkcyk7XG4gICAgaWYgKHdoZXJlKSB2YWxpZGF0ZVdoZXJlKHdoZXJlKTtcbiAgICBpZiAod2hlcmVEb2N1bWVudCkgdmFsaWRhdGVXaGVyZURvY3VtZW50KHdoZXJlRG9jdW1lbnQpO1xuICB9XG4gIGFzeW5jIHByZXBhcmVRdWVyeShyZWNvcmRTZXQsIGluY2x1ZGUsIGlkcywgd2hlcmUsIHdoZXJlRG9jdW1lbnQsIG5SZXN1bHRzKSB7XG4gICAgdmFsaWRhdGVCYXNlUmVjb3JkU2V0KHtcbiAgICAgIHJlY29yZFNldCxcbiAgICAgIGVtYmVkZGluZ3NGaWVsZDogXCJxdWVyeUVtYmVkZGluZ3NcIixcbiAgICAgIGRvY3VtZW50c0ZpZWxkOiBcInF1ZXJ5VGV4dHNcIlxuICAgIH0pO1xuICAgIHZhbGlkYXRlSW5jbHVkZSh7IGluY2x1ZGUgfSk7XG4gICAgaWYgKGlkcykgdmFsaWRhdGVJRHMoaWRzKTtcbiAgICBpZiAod2hlcmUpIHZhbGlkYXRlV2hlcmUod2hlcmUpO1xuICAgIGlmICh3aGVyZURvY3VtZW50KSB2YWxpZGF0ZVdoZXJlRG9jdW1lbnQod2hlcmVEb2N1bWVudCk7XG4gICAgaWYgKG5SZXN1bHRzKSB2YWxpZGF0ZU5SZXN1bHRzKG5SZXN1bHRzKTtcbiAgICBsZXQgZW1iZWRkaW5ncztcbiAgICBpZiAoIXJlY29yZFNldC5lbWJlZGRpbmdzKSB7XG4gICAgICBlbWJlZGRpbmdzID0gYXdhaXQgdGhpcy5lbWJlZChyZWNvcmRTZXQuZG9jdW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1iZWRkaW5ncyA9IHJlY29yZFNldC5lbWJlZGRpbmdzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVjb3JkU2V0LFxuICAgICAgaWRzLFxuICAgICAgZW1iZWRkaW5nc1xuICAgIH07XG4gIH1cbiAgdmFsaWRhdGVEZWxldGUoaWRzLCB3aGVyZSwgd2hlcmVEb2N1bWVudCkge1xuICAgIGlmIChpZHMpIHZhbGlkYXRlSURzKGlkcyk7XG4gICAgaWYgKHdoZXJlKSB2YWxpZGF0ZVdoZXJlKHdoZXJlKTtcbiAgICBpZiAod2hlcmVEb2N1bWVudCkgdmFsaWRhdGVXaGVyZURvY3VtZW50KHdoZXJlRG9jdW1lbnQpO1xuICB9XG4gIGFzeW5jIGNvdW50KCkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuY29sbGVjdGlvbkNvdW50KHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiBhd2FpdCB0aGlzLnBhdGgoKVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGFzeW5jIGFkZCh7XG4gICAgaWRzLFxuICAgIGVtYmVkZGluZ3MsXG4gICAgbWV0YWRhdGFzLFxuICAgIGRvY3VtZW50cyxcbiAgICB1cmlzXG4gIH0pIHtcbiAgICBjb25zdCByZWNvcmRTZXQgPSB7XG4gICAgICBpZHMsXG4gICAgICBlbWJlZGRpbmdzLFxuICAgICAgZG9jdW1lbnRzLFxuICAgICAgbWV0YWRhdGFzLFxuICAgICAgdXJpc1xuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZWRSZWNvcmRTZXQgPSBhd2FpdCB0aGlzLnByZXBhcmVSZWNvcmRzKHsgcmVjb3JkU2V0IH0pO1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNvbGxlY3Rpb25BZGQoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpLFxuICAgICAgYm9keToge1xuICAgICAgICBpZHM6IHByZXBhcmVkUmVjb3JkU2V0LmlkcyxcbiAgICAgICAgZW1iZWRkaW5nczogcHJlcGFyZWRSZWNvcmRTZXQuZW1iZWRkaW5ncyxcbiAgICAgICAgZG9jdW1lbnRzOiBwcmVwYXJlZFJlY29yZFNldC5kb2N1bWVudHMsXG4gICAgICAgIG1ldGFkYXRhczogcHJlcGFyZWRSZWNvcmRTZXQubWV0YWRhdGFzLFxuICAgICAgICB1cmlzOiBwcmVwYXJlZFJlY29yZFNldC51cmlzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0KGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkcyxcbiAgICAgIHdoZXJlLFxuICAgICAgbGltaXQsXG4gICAgICBvZmZzZXQsXG4gICAgICB3aGVyZURvY3VtZW50LFxuICAgICAgaW5jbHVkZSA9IFtcImRvY3VtZW50c1wiLCBcIm1ldGFkYXRhc1wiXVxuICAgIH0gPSBhcmdzO1xuICAgIHRoaXMudmFsaWRhdGVHZXQoaW5jbHVkZSwgaWRzLCB3aGVyZSwgd2hlcmVEb2N1bWVudCk7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5jb2xsZWN0aW9uR2V0KHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiBhd2FpdCB0aGlzLnBhdGgoKSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgaWRzLFxuICAgICAgICB3aGVyZSxcbiAgICAgICAgbGltaXQsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgd2hlcmVfZG9jdW1lbnQ6IHdoZXJlRG9jdW1lbnQsXG4gICAgICAgIGluY2x1ZGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEdldFJlc3VsdCh7XG4gICAgICBkb2N1bWVudHM6IGRhdGEuZG9jdW1lbnRzID8/IFtdLFxuICAgICAgZW1iZWRkaW5nczogZGF0YS5lbWJlZGRpbmdzID8/IFtdLFxuICAgICAgaWRzOiBkYXRhLmlkcyxcbiAgICAgIGluY2x1ZGU6IGRhdGEuaW5jbHVkZSxcbiAgICAgIG1ldGFkYXRhczogZGF0YS5tZXRhZGF0YXMgPz8gW10sXG4gICAgICB1cmlzOiBkYXRhLnVyaXMgPz8gW11cbiAgICB9KTtcbiAgfVxuICBhc3luYyBwZWVrKHsgbGltaXQgPSAxMCB9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHsgbGltaXQgfSk7XG4gIH1cbiAgYXN5bmMgcXVlcnkoe1xuICAgIHF1ZXJ5RW1iZWRkaW5ncyxcbiAgICBxdWVyeVRleHRzLFxuICAgIHF1ZXJ5VVJJcyxcbiAgICBpZHMsXG4gICAgblJlc3VsdHMgPSAxMCxcbiAgICB3aGVyZSxcbiAgICB3aGVyZURvY3VtZW50LFxuICAgIGluY2x1ZGUgPSBbXCJtZXRhZGF0YXNcIiwgXCJkb2N1bWVudHNcIiwgXCJkaXN0YW5jZXNcIl1cbiAgfSkge1xuICAgIGNvbnN0IHJlY29yZFNldCA9IHtcbiAgICAgIGVtYmVkZGluZ3M6IHF1ZXJ5RW1iZWRkaW5ncyxcbiAgICAgIGRvY3VtZW50czogcXVlcnlUZXh0cyxcbiAgICAgIHVyaXM6IHF1ZXJ5VVJJc1xuICAgIH07XG4gICAgY29uc3QgcXVlcnlSZWNvcmRTZXQgPSBhd2FpdCB0aGlzLnByZXBhcmVRdWVyeShcbiAgICAgIHJlY29yZFNldCxcbiAgICAgIGluY2x1ZGUsXG4gICAgICBpZHMsXG4gICAgICB3aGVyZSxcbiAgICAgIHdoZXJlRG9jdW1lbnQsXG4gICAgICBuUmVzdWx0c1xuICAgICk7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5jb2xsZWN0aW9uUXVlcnkoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpLFxuICAgICAgYm9keToge1xuICAgICAgICBpZHM6IHF1ZXJ5UmVjb3JkU2V0LmlkcyxcbiAgICAgICAgaW5jbHVkZSxcbiAgICAgICAgbl9yZXN1bHRzOiBuUmVzdWx0cyxcbiAgICAgICAgcXVlcnlfZW1iZWRkaW5nczogcXVlcnlSZWNvcmRTZXQuZW1iZWRkaW5ncyxcbiAgICAgICAgd2hlcmUsXG4gICAgICAgIHdoZXJlX2RvY3VtZW50OiB3aGVyZURvY3VtZW50XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBRdWVyeVJlc3VsdCh7XG4gICAgICBkaXN0YW5jZXM6IGRhdGEuZGlzdGFuY2VzID8/IFtdLFxuICAgICAgZG9jdW1lbnRzOiBkYXRhLmRvY3VtZW50cyA/PyBbXSxcbiAgICAgIGVtYmVkZGluZ3M6IGRhdGEuZW1iZWRkaW5ncyA/PyBbXSxcbiAgICAgIGlkczogZGF0YS5pZHMgPz8gW10sXG4gICAgICBpbmNsdWRlOiBkYXRhLmluY2x1ZGUsXG4gICAgICBtZXRhZGF0YXM6IGRhdGEubWV0YWRhdGFzID8/IFtdLFxuICAgICAgdXJpczogZGF0YS51cmlzID8/IFtdXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbW9kaWZ5KHtcbiAgICBuYW1lLFxuICAgIG1ldGFkYXRhLFxuICAgIGNvbmZpZ3VyYXRpb25cbiAgfSkge1xuICAgIGlmIChuYW1lKSB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgdmFsaWRhdGVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgfVxuICAgIGNvbnN0IHsgdXBkYXRlQ29uZmlndXJhdGlvbiwgdXBkYXRlRW1iZWRkaW5nRnVuY3Rpb24gfSA9IGNvbmZpZ3VyYXRpb24gPyBhd2FpdCBwcm9jZXNzVXBkYXRlQ29sbGVjdGlvbkNvbmZpZyh7XG4gICAgICBjb2xsZWN0aW9uTmFtZTogdGhpcy5uYW1lLFxuICAgICAgY3VycmVudENvbmZpZ3VyYXRpb246IHRoaXMuY29uZmlndXJhdGlvbixcbiAgICAgIG5ld0NvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sXG4gICAgICBjdXJyZW50RW1iZWRkaW5nRnVuY3Rpb246IHRoaXMuZW1iZWRkaW5nRnVuY3Rpb25cbiAgICB9KSA6IHt9O1xuICAgIGlmICh1cGRhdGVFbWJlZGRpbmdGdW5jdGlvbikge1xuICAgICAgdGhpcy5lbWJlZGRpbmdGdW5jdGlvbiA9IHVwZGF0ZUVtYmVkZGluZ0Z1bmN0aW9uO1xuICAgIH1cbiAgICBpZiAodXBkYXRlQ29uZmlndXJhdGlvbikge1xuICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0ge1xuICAgICAgICBobnN3OiB7IC4uLnRoaXMuY29uZmlndXJhdGlvbi5obnN3LCAuLi51cGRhdGVDb25maWd1cmF0aW9uLmhuc3cgfSxcbiAgICAgICAgc3Bhbm46IHsgLi4udGhpcy5jb25maWd1cmF0aW9uLnNwYW5uLCAuLi51cGRhdGVDb25maWd1cmF0aW9uLnNwYW5uIH0sXG4gICAgICAgIGVtYmVkZGluZ0Z1bmN0aW9uOiB1cGRhdGVDb25maWd1cmF0aW9uLmVtYmVkZGluZ19mdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgYXdhaXQgRGVmYXVsdFNlcnZpY2UudXBkYXRlQ29sbGVjdGlvbih7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIG5ld19uYW1lOiBuYW1lLFxuICAgICAgICBuZXdfbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICBuZXdfY29uZmlndXJhdGlvbjogdXBkYXRlQ29uZmlndXJhdGlvblxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZvcmsoeyBuYW1lIH0pIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmZvcmtDb2xsZWN0aW9uKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiBhd2FpdCB0aGlzLnBhdGgoKSxcbiAgICAgIGJvZHk6IHsgbmV3X25hbWU6IG5hbWUgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgX0NvbGxlY3Rpb25JbXBsKHtcbiAgICAgIGNocm9tYUNsaWVudDogdGhpcy5jaHJvbWFDbGllbnQsXG4gICAgICBhcGlDbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICBlbWJlZGRpbmdGdW5jdGlvbjogdGhpcy5fZW1iZWRkaW5nRnVuY3Rpb24sXG4gICAgICBtZXRhZGF0YTogZGF0YS5tZXRhZGF0YSA/PyB2b2lkIDAsXG4gICAgICBjb25maWd1cmF0aW9uOiBkYXRhLmNvbmZpZ3VyYXRpb25fanNvblxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZSh7XG4gICAgaWRzLFxuICAgIGVtYmVkZGluZ3MsXG4gICAgbWV0YWRhdGFzLFxuICAgIGRvY3VtZW50cyxcbiAgICB1cmlzXG4gIH0pIHtcbiAgICBjb25zdCByZWNvcmRTZXQgPSB7XG4gICAgICBpZHMsXG4gICAgICBlbWJlZGRpbmdzLFxuICAgICAgZG9jdW1lbnRzLFxuICAgICAgbWV0YWRhdGFzLFxuICAgICAgdXJpc1xuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZWRSZWNvcmRTZXQgPSBhd2FpdCB0aGlzLnByZXBhcmVSZWNvcmRzKHtcbiAgICAgIHJlY29yZFNldCxcbiAgICAgIHVwZGF0ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNvbGxlY3Rpb25VcGRhdGUoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpLFxuICAgICAgYm9keToge1xuICAgICAgICBpZHM6IHByZXBhcmVkUmVjb3JkU2V0LmlkcyxcbiAgICAgICAgZW1iZWRkaW5nczogcHJlcGFyZWRSZWNvcmRTZXQuZW1iZWRkaW5ncyxcbiAgICAgICAgbWV0YWRhdGFzOiBwcmVwYXJlZFJlY29yZFNldC5tZXRhZGF0YXMsXG4gICAgICAgIHVyaXM6IHByZXBhcmVkUmVjb3JkU2V0LnVyaXMsXG4gICAgICAgIGRvY3VtZW50czogcHJlcGFyZWRSZWNvcmRTZXQuZG9jdW1lbnRzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBzZXJ0KHtcbiAgICBpZHMsXG4gICAgZW1iZWRkaW5ncyxcbiAgICBtZXRhZGF0YXMsXG4gICAgZG9jdW1lbnRzLFxuICAgIHVyaXNcbiAgfSkge1xuICAgIGNvbnN0IHJlY29yZFNldCA9IHtcbiAgICAgIGlkcyxcbiAgICAgIGVtYmVkZGluZ3MsXG4gICAgICBkb2N1bWVudHMsXG4gICAgICBtZXRhZGF0YXMsXG4gICAgICB1cmlzXG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlZFJlY29yZFNldCA9IGF3YWl0IHRoaXMucHJlcGFyZVJlY29yZHMoe1xuICAgICAgcmVjb3JkU2V0XG4gICAgfSk7XG4gICAgYXdhaXQgRGVmYXVsdFNlcnZpY2UuY29sbGVjdGlvblVwc2VydCh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIGlkczogcHJlcGFyZWRSZWNvcmRTZXQuaWRzLFxuICAgICAgICBlbWJlZGRpbmdzOiBwcmVwYXJlZFJlY29yZFNldC5lbWJlZGRpbmdzLFxuICAgICAgICBtZXRhZGF0YXM6IHByZXBhcmVkUmVjb3JkU2V0Lm1ldGFkYXRhcyxcbiAgICAgICAgdXJpczogcHJlcGFyZWRSZWNvcmRTZXQudXJpcyxcbiAgICAgICAgZG9jdW1lbnRzOiBwcmVwYXJlZFJlY29yZFNldC5kb2N1bWVudHNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBkZWxldGUoe1xuICAgIGlkcyxcbiAgICB3aGVyZSxcbiAgICB3aGVyZURvY3VtZW50XG4gIH0pIHtcbiAgICB0aGlzLnZhbGlkYXRlRGVsZXRlKGlkcywgd2hlcmUsIHdoZXJlRG9jdW1lbnQpO1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNvbGxlY3Rpb25EZWxldGUoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpLFxuICAgICAgYm9keToge1xuICAgICAgICBpZHMsXG4gICAgICAgIHdoZXJlLFxuICAgICAgICB3aGVyZV9kb2N1bWVudDogd2hlcmVEb2N1bWVudFxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbmV4dC50c1xuZnVuY3Rpb24gd2l0aENocm9tYSh1c2VyTmV4dENvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IG9yaWdpbmFsV2VicGFja0Z1bmN0aW9uID0gdXNlck5leHRDb25maWcud2VicGFjaztcbiAgY29uc3QgbmV3V2VicGFja0Z1bmN0aW9uID0gKGNvbmZpZywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWcuZXh0ZXJuYWxzKSkge1xuICAgICAgY29uZmlnLmV4dGVybmFscyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBleHRlcm5hbHNUb0FkZCA9IFtcIkBodWdnaW5nZmFjZS90cmFuc2Zvcm1lcnNcIiwgXCJjaHJvbWFkYlwiXTtcbiAgICBmb3IgKGNvbnN0IGV4dCBvZiBleHRlcm5hbHNUb0FkZCkge1xuICAgICAgaWYgKCFjb25maWcuZXh0ZXJuYWxzLmluY2x1ZGVzKGV4dCkpIHtcbiAgICAgICAgY29uZmlnLmV4dGVybmFscy5wdXNoKGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxXZWJwYWNrRnVuY3Rpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG9yaWdpbmFsV2VicGFja0Z1bmN0aW9uKGNvbmZpZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG4gIH07XG4gIHJldHVybiB7XG4gICAgLi4udXNlck5leHRDb25maWcsXG4gICAgd2VicGFjazogbmV3V2VicGFja0Z1bmN0aW9uXG4gIH07XG59XG5cbi8vIHNyYy9jaHJvbWEtZmV0Y2gudHNcbnZhciBvZmZsaW5lRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgKGVycm9yPy5uYW1lID09PSBcIlR5cGVFcnJvclwiIHx8IGVycm9yPy5uYW1lID09PSBcIkZldGNoRXJyb3JcIikgJiYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKFwiZmV0Y2ggZmFpbGVkXCIpIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKFwiRU5PVEZPVU5EXCIpKVxuICApO1xufTtcbnZhciBjaHJvbWFGZXRjaCA9IGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2U7XG4gIHRyeSB7XG4gICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpbnB1dCwgaW5pdCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChvZmZsaW5lRXJyb3IoZXJyKSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYUNvbm5lY3Rpb25FcnJvcihcbiAgICAgICAgXCJGYWlsZWQgdG8gY29ubmVjdCB0byBjaHJvbWFkYi4gTWFrZSBzdXJlIHlvdXIgc2VydmVyIGlzIHJ1bm5pbmcgYW5kIHRyeSBhZ2Fpbi4gSWYgeW91IGFyZSBydW5uaW5nIGZyb20gYSBicm93c2VyLCBtYWtlIHN1cmUgdGhhdCB5b3VyIGNocm9tYWRiIGluc3RhbmNlIGlzIGNvbmZpZ3VyZWQgdG8gYWxsb3cgcmVxdWVzdHMgZnJvbSB0aGUgY3VycmVudCBvcmlnaW4gdXNpbmcgdGhlIENIUk9NQV9TRVJWRVJfQ09SU19BTExPV19PUklHSU5TIGVudmlyb25tZW50IHZhcmlhYmxlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQ2hyb21hQ29ubmVjdGlvbkVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gQ2hyb21hXCIpO1xuICB9XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1cykge1xuICAgIGNhc2UgNDAwOlxuICAgICAgbGV0IHN0YXR1cyA9IFwiQmFkIFJlcXVlc3RcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc3RhdHVzID0gcmVzcG9uc2VCb2R5Lm1lc3NhZ2UgfHwgc3RhdHVzO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hQ2xpZW50RXJyb3IoXG4gICAgICAgIGBCYWQgcmVxdWVzdCB0byAke2lucHV0LnVybCB8fCBcIkNocm9tYVwifSB3aXRoIHN0YXR1czogJHtzdGF0dXN9YFxuICAgICAgKTtcbiAgICBjYXNlIDQwMTpcbiAgICAgIHRocm93IG5ldyBDaHJvbWFVbmF1dGhvcml6ZWRFcnJvcihgVW5hdXRob3JpemVkYCk7XG4gICAgY2FzZSA0MDM6XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hRm9yYmlkZGVuRXJyb3IoXG4gICAgICAgIGBZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhlIHJlcXVlc3RlZCByZXNvdXJjZS5gXG4gICAgICApO1xuICAgIGNhc2UgNDA0OlxuICAgICAgdGhyb3cgbmV3IENocm9tYU5vdEZvdW5kRXJyb3IoXG4gICAgICAgIGBUaGUgcmVxdWVzdGVkIHJlc291cmNlIGNvdWxkIG5vdCBiZSBmb3VuZGBcbiAgICAgICk7XG4gICAgY2FzZSA0MDk6XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hVW5pcXVlRXJyb3IoXCJUaGUgcmVzb3VyY2UgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgY2FzZSA0MjI6XG4gICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgaWYgKGJvZHkgJiYgYm9keS5tZXNzYWdlICYmIChib2R5Lm1lc3NhZ2Uuc3RhcnRzV2l0aChcIlF1b3RhIGV4Y2VlZGVkXCIpIHx8IGJvZHkubWVzc2FnZS5zdGFydHNXaXRoKFwiQmlsbGluZyBsaW1pdCBleGNlZWRlZFwiKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IENocm9tYVF1b3RhRXhjZWVkZWRFcnJvcihib2R5Py5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDI5OlxuICAgICAgdGhyb3cgbmV3IENocm9tYVJhdGVMaW1pdEVycm9yKFwiUmF0ZSBsaW1pdCBleGNlZWRlZFwiKTtcbiAgfVxuICB0aHJvdyBuZXcgQ2hyb21hQ29ubmVjdGlvbkVycm9yKFxuICAgIGBVbmFibGUgdG8gY29ubmVjdCB0byB0aGUgY2hyb21hZGIgc2VydmVyIChzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSkuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuYFxuICApO1xufTtcblxuLy8gc3JjL2FkbWluLWNsaWVudC50c1xudmFyIEFkbWluQ2xpZW50ID0gY2xhc3Mge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBBZG1pbkNsaWVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgYWRtaW4gY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgY29uc3QgeyBob3N0LCBwb3J0LCBzc2wsIGhlYWRlcnMsIGZldGNoT3B0aW9ucyB9ID0gYXJncyB8fCBkZWZhdWx0QWRtaW5DbGllbnRBcmdzO1xuICAgIGNvbnN0IGJhc2VVcmwgPSBgJHtzc2wgPyBcImh0dHBzXCIgOiBcImh0dHBcIn06Ly8ke2hvc3R9OiR7cG9ydH1gO1xuICAgIGNvbnN0IGNvbmZpZ09wdGlvbnMgPSB7XG4gICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICBtZXRob2Q6IG5vcm1hbGl6ZU1ldGhvZChmZXRjaE9wdGlvbnM/Lm1ldGhvZCksXG4gICAgICBiYXNlVXJsLFxuICAgICAgaGVhZGVyc1xuICAgIH07XG4gICAgdGhpcy5hcGlDbGllbnQgPSBKKHcoY29uZmlnT3B0aW9ucykpO1xuICAgIHRoaXMuYXBpQ2xpZW50LnNldENvbmZpZyh7IGZldGNoOiBjaHJvbWFGZXRjaCB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBkYXRhYmFzZSB3aXRoaW4gYSB0ZW5hbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gRGF0YWJhc2UgY3JlYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gTmFtZSBvZiB0aGUgZGF0YWJhc2UgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBvcHRpb25zLnRlbmFudCAtIFRlbmFudCB0aGF0IHdpbGwgb3duIHRoZSBkYXRhYmFzZVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlRGF0YWJhc2Uoe1xuICAgIG5hbWUsXG4gICAgdGVuYW50XG4gIH0pIHtcbiAgICBhd2FpdCBEZWZhdWx0U2VydmljZS5jcmVhdGVEYXRhYmFzZSh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogeyB0ZW5hbnQgfSxcbiAgICAgIGJvZHk6IHsgbmFtZSB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIGRhdGFiYXNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIERhdGFiYXNlIHJldHJpZXZhbCBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhYmFzZSB0byByZXRyaWV2ZVxuICAgKiBAcGFyYW0gb3B0aW9ucy50ZW5hbnQgLSBUZW5hbnQgdGhhdCBvd25zIHRoZSBkYXRhYmFzZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBkYXRhYmFzZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0RGF0YWJhc2Uoe1xuICAgIG5hbWUsXG4gICAgdGVuYW50XG4gIH0pIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmdldERhdGFiYXNlKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiB7IHRlbmFudCwgZGF0YWJhc2U6IG5hbWUgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgZGF0YWJhc2UgYW5kIGFsbCBpdHMgZGF0YS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBEYXRhYmFzZSBkZWxldGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhYmFzZSB0byBkZWxldGVcbiAgICogQHBhcmFtIG9wdGlvbnMudGVuYW50IC0gVGVuYW50IHRoYXQgb3ducyB0aGUgZGF0YWJhc2VcbiAgICogQHdhcm5pbmcgVGhpcyBvcGVyYXRpb24gaXMgaXJyZXZlcnNpYmxlIGFuZCB3aWxsIGRlbGV0ZSBhbGwgZGF0YVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlRGF0YWJhc2Uoe1xuICAgIG5hbWUsXG4gICAgdGVuYW50XG4gIH0pIHtcbiAgICBhd2FpdCBEZWZhdWx0U2VydmljZS5kZWxldGVEYXRhYmFzZSh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogeyB0ZW5hbnQsIGRhdGFiYXNlOiBuYW1lIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIGRhdGFiYXNlcyB3aXRoaW4gYSB0ZW5hbnQuXG4gICAqIEBwYXJhbSBhcmdzIC0gTGlzdGluZyBwYXJhbWV0ZXJzIGluY2x1ZGluZyB0ZW5hbnQgYW5kIHBhZ2luYXRpb25cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgZGF0YWJhc2UgaW5mb3JtYXRpb25cbiAgICovXG4gIGFzeW5jIGxpc3REYXRhYmFzZXMoYXJncykge1xuICAgIGNvbnN0IHsgbGltaXQgPSAxMDAsIG9mZnNldCA9IDAsIHRlbmFudCB9ID0gYXJncztcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmxpc3REYXRhYmFzZXMoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IHsgdGVuYW50IH0sXG4gICAgICBxdWVyeTogeyBsaW1pdCwgb2Zmc2V0IH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0ZW5hbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGVuYW50IGNyZWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIE5hbWUgb2YgdGhlIHRlbmFudCB0byBjcmVhdGVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRlbmFudCh7IG5hbWUgfSkge1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNyZWF0ZVRlbmFudCh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgYm9keTogeyBuYW1lIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgdGVuYW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRlbmFudCByZXRyaWV2YWwgb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gTmFtZSBvZiB0aGUgdGVuYW50IHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0ZW5hbnQgbmFtZVxuICAgKi9cbiAgYXN5bmMgZ2V0VGVuYW50KHsgbmFtZSB9KSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5nZXRUZW5hbnQoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IHsgdGVuYW50X25hbWU6IG5hbWUgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhLm5hbWU7XG4gIH1cbn07XG5cbi8vIHNyYy9jaHJvbWEtY2xpZW50LnRzXG5pbXBvcnQgKiBhcyBwcm9jZXNzIGZyb20gXCJub2RlOnByb2Nlc3NcIjtcbnZhciBDaHJvbWFDbGllbnQgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENocm9tYUNsaWVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MgPSB7fSkge1xuICAgIGxldCB7XG4gICAgICBob3N0ID0gZGVmYXVsdENocm9tYUNsaWVudEFyZ3MuaG9zdCxcbiAgICAgIHBvcnQgPSBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncy5wb3J0LFxuICAgICAgc3NsID0gZGVmYXVsdENocm9tYUNsaWVudEFyZ3Muc3NsLFxuICAgICAgdGVuYW50ID0gZGVmYXVsdENocm9tYUNsaWVudEFyZ3MudGVuYW50LFxuICAgICAgZGF0YWJhc2UgPSBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncy5kYXRhYmFzZSxcbiAgICAgIGhlYWRlcnMgPSBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncy5oZWFkZXJzLFxuICAgICAgZmV0Y2hPcHRpb25zID0gZGVmYXVsdENocm9tYUNsaWVudEFyZ3MuZmV0Y2hPcHRpb25zXG4gICAgfSA9IGFyZ3M7XG4gICAgaWYgKGFyZ3MucGF0aCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIlRoZSAncGF0aCcgYXJndW1lbnQgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAnc3NsJywgJ2hvc3QnLCBhbmQgJ3BvcnQnIGluc3RlYWRcIlxuICAgICAgKTtcbiAgICAgIGNvbnN0IHBhcnNlZFBhdGggPSBwYXJzZUNvbm5lY3Rpb25QYXRoKGFyZ3MucGF0aCk7XG4gICAgICBzc2wgPSBwYXJzZWRQYXRoLnNzbDtcbiAgICAgIGhvc3QgPSBwYXJzZWRQYXRoLmhvc3Q7XG4gICAgICBwb3J0ID0gcGFyc2VkUGF0aC5wb3J0O1xuICAgIH1cbiAgICBpZiAoYXJncy5hdXRoKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVGhlICdhdXRoJyBhcmd1bWVudCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICdoZWFkZXJzJyBpbnN0ZWFkXCJcbiAgICAgICk7XG4gICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgaGVhZGVycyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKCFoZWFkZXJzW1wieC1jaHJvbWEtdG9rZW5cIl0gJiYgYXJncy5hdXRoLnRva2VuSGVhZGVyVHlwZSA9PT0gXCJYX0NIUk9NQV9UT0tFTlwiICYmIGFyZ3MuYXV0aC5jcmVkZW50aWFscykge1xuICAgICAgICBoZWFkZXJzW1wieC1jaHJvbWEtdG9rZW5cIl0gPSBhcmdzLmF1dGguY3JlZGVudGlhbHM7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJhc2VVcmwgPSBgJHtzc2wgPyBcImh0dHBzXCIgOiBcImh0dHBcIn06Ly8ke2hvc3R9OiR7cG9ydH1gO1xuICAgIHRoaXMuX3RlbmFudCA9IHRlbmFudCB8fCBwcm9jZXNzLmVudi5DSFJPTUFfVEVOQU5UO1xuICAgIHRoaXMuX2RhdGFiYXNlID0gZGF0YWJhc2UgfHwgcHJvY2Vzcy5lbnYuQ0hST01BX0RBVEFCQVNFO1xuICAgIGNvbnN0IGNvbmZpZ09wdGlvbnMgPSB7XG4gICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICBtZXRob2Q6IG5vcm1hbGl6ZU1ldGhvZChmZXRjaE9wdGlvbnM/Lm1ldGhvZCksXG4gICAgICBiYXNlVXJsLFxuICAgICAgaGVhZGVyc1xuICAgIH07XG4gICAgdGhpcy5hcGlDbGllbnQgPSBKKHcoY29uZmlnT3B0aW9ucykpO1xuICAgIHRoaXMuYXBpQ2xpZW50LnNldENvbmZpZyh7IGZldGNoOiBjaHJvbWFGZXRjaCB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB0ZW5hbnQgbmFtZS5cbiAgICogQHJldHVybnMgVGhlIHRlbmFudCBuYW1lIG9yIHVuZGVmaW5lZCBpZiBub3Qgc2V0XG4gICAqL1xuICBnZXQgdGVuYW50KCkge1xuICAgIHJldHVybiB0aGlzLl90ZW5hbnQ7XG4gIH1cbiAgc2V0IHRlbmFudCh0ZW5hbnQpIHtcbiAgICB0aGlzLl90ZW5hbnQgPSB0ZW5hbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgZGF0YWJhc2UgbmFtZS5cbiAgICogQHJldHVybnMgVGhlIGRhdGFiYXNlIG5hbWUgb3IgdW5kZWZpbmVkIGlmIG5vdCBzZXRcbiAgICovXG4gIGdldCBkYXRhYmFzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YWJhc2U7XG4gIH1cbiAgc2V0IGRhdGFiYXNlKGRhdGFiYXNlKSB7XG4gICAgdGhpcy5fZGF0YWJhc2UgPSBkYXRhYmFzZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcHJlZmxpZ2h0IGNoZWNrc1xuICAgKiBAcmV0dXJucyBUaGUgcHJlZmxpZ2h0IGNoZWNrcyBvciB1bmRlZmluZWQgaWYgbm90IHNldFxuICAgKi9cbiAgZ2V0IHByZWZsaWdodENoZWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlZmxpZ2h0Q2hlY2tzO1xuICB9XG4gIHNldCBwcmVmbGlnaHRDaGVja3MocHJlZmxpZ2h0Q2hlY2tzKSB7XG4gICAgdGhpcy5fcHJlZmxpZ2h0Q2hlY2tzID0gcHJlZmxpZ2h0Q2hlY2tzO1xuICB9XG4gIC8qKiBAaWdub3JlICovXG4gIGFzeW5jIF9wYXRoKCkge1xuICAgIGlmICghdGhpcy5fdGVuYW50IHx8ICF0aGlzLl9kYXRhYmFzZSkge1xuICAgICAgY29uc3QgeyB0ZW5hbnQsIGRhdGFiYXNlcyB9ID0gYXdhaXQgdGhpcy5nZXRVc2VySWRlbnRpdHkoKTtcbiAgICAgIGNvbnN0IHVuaXF1ZURCcyA9IFsuLi5uZXcgU2V0KGRhdGFiYXNlcyldO1xuICAgICAgdGhpcy5fdGVuYW50ID0gdGVuYW50O1xuICAgICAgaWYgKHVuaXF1ZURCcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IENocm9tYVVuYXV0aG9yaXplZEVycm9yKFxuICAgICAgICAgIGBZb3VyIEFQSSBrZXkgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYW55IERCcyBmb3IgdGVuYW50ICR7dGhpcy50ZW5hbnR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHVuaXF1ZURCcy5sZW5ndGggPiAxIHx8IHVuaXF1ZURCc1swXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgICAgXCJZb3VyIEFQSSBrZXkgaXMgc2NvcGVkIHRvIG1vcmUgdGhhbiAxIERCLiBQbGVhc2UgcHJvdmlkZSBhIERCIG5hbWUgdG8gdGhlIENsb3VkQ2xpZW50IGNvbnN0cnVjdG9yXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RhdGFiYXNlID0gdW5pcXVlREJzWzBdO1xuICAgIH1cbiAgICByZXR1cm4geyB0ZW5hbnQ6IHRoaXMuX3RlbmFudCwgZGF0YWJhc2U6IHRoaXMuX2RhdGFiYXNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVzZXIgaWRlbnRpdHkgaW5mb3JtYXRpb24gaW5jbHVkaW5nIHRlbmFudCBhbmQgYWNjZXNzaWJsZSBkYXRhYmFzZXMuXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHVzZXIgaWRlbnRpdHkgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcklkZW50aXR5KCkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuZ2V0VXNlcklkZW50aXR5KHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnRcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBoZWFydGJlYXQgcmVxdWVzdCB0byBjaGVjayBzZXJ2ZXIgY29ubmVjdGl2aXR5LlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgc2VydmVyJ3MgbmFub3NlY29uZCBoZWFydGJlYXQgdGltZXN0YW1wXG4gICAqL1xuICBhc3luYyBoZWFydGJlYXQoKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5oZWFydGJlYXQoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhW1wibmFub3NlY29uZCBoZWFydGJlYXRcIl07XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBjb2xsZWN0aW9ucyBpbiB0aGUgY3VycmVudCBkYXRhYmFzZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBPcHRpb25hbCBwYWdpbmF0aW9uIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIGFyZ3MubGltaXQgLSBNYXhpbXVtIG51bWJlciBvZiBjb2xsZWN0aW9ucyB0byByZXR1cm4gKGRlZmF1bHQ6IDEwMClcbiAgICogQHBhcmFtIGFyZ3Mub2Zmc2V0IC0gTnVtYmVyIG9mIGNvbGxlY3Rpb25zIHRvIHNraXAgKGRlZmF1bHQ6IDApXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIENvbGxlY3Rpb24gaW5zdGFuY2VzXG4gICAqL1xuICBhc3luYyBsaXN0Q29sbGVjdGlvbnMoYXJncykge1xuICAgIGNvbnN0IHsgbGltaXQgPSAxMDAsIG9mZnNldCA9IDAgfSA9IGFyZ3MgfHwge307XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5saXN0Q29sbGVjdGlvbnMoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMuX3BhdGgoKSxcbiAgICAgIHF1ZXJ5OiB7IGxpbWl0LCBvZmZzZXQgfVxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIGRhdGEubWFwKFxuICAgICAgICBhc3luYyAoY29sbGVjdGlvbikgPT4gbmV3IENvbGxlY3Rpb25JbXBsKHtcbiAgICAgICAgICBjaHJvbWFDbGllbnQ6IHRoaXMsXG4gICAgICAgICAgYXBpQ2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgICAgICBuYW1lOiBjb2xsZWN0aW9uLm5hbWUsXG4gICAgICAgICAgaWQ6IGNvbGxlY3Rpb24uaWQsXG4gICAgICAgICAgZW1iZWRkaW5nRnVuY3Rpb246IGF3YWl0IGdldEVtYmVkZGluZ0Z1bmN0aW9uKFxuICAgICAgICAgICAgY29sbGVjdGlvbi5uYW1lLFxuICAgICAgICAgICAgY29sbGVjdGlvbi5jb25maWd1cmF0aW9uX2pzb24uZW1iZWRkaW5nX2Z1bmN0aW9uID8/IHZvaWQgMFxuICAgICAgICAgICksXG4gICAgICAgICAgY29uZmlndXJhdGlvbjogY29sbGVjdGlvbi5jb25maWd1cmF0aW9uX2pzb24sXG4gICAgICAgICAgbWV0YWRhdGE6IGNvbGxlY3Rpb24ubWV0YWRhdGEgPz8gdm9pZCAwXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIGNvbGxlY3Rpb25zIGluIHRoZSBjdXJyZW50IGRhdGFiYXNlLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBjb3VudFxuICAgKi9cbiAgYXN5bmMgY291bnRDb2xsZWN0aW9ucygpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNvdW50Q29sbGVjdGlvbnMoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMuX3BhdGgoKVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29sbGVjdGlvbiBjcmVhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWd1cmF0aW9uIC0gT3B0aW9uYWwgY29sbGVjdGlvbiBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBvcHRpb25zLm1ldGFkYXRhIC0gT3B0aW9uYWwgbWV0YWRhdGEgZm9yIHRoZSBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSBvcHRpb25zLmVtYmVkZGluZ0Z1bmN0aW9uIC0gT3B0aW9uYWwgZW1iZWRkaW5nIGZ1bmN0aW9uIHRvIHVzZS4gRGVmYXVsdHMgdG8gYERlZmF1bHRFbWJlZGRpbmdGdW5jdGlvbmAgZnJvbSBAY2hyb21hLWNvcmUvZGVmYXVsdC1lbWJlZFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3JlYXRlZCBDb2xsZWN0aW9uIGluc3RhbmNlXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgYSBjb2xsZWN0aW9uIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0c1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlQ29sbGVjdGlvbih7XG4gICAgbmFtZSxcbiAgICBjb25maWd1cmF0aW9uLFxuICAgIG1ldGFkYXRhLFxuICAgIGVtYmVkZGluZ0Z1bmN0aW9uXG4gIH0pIHtcbiAgICBjb25zdCBjb2xsZWN0aW9uQ29uZmlnID0gYXdhaXQgcHJvY2Vzc0NyZWF0ZUNvbGxlY3Rpb25Db25maWcoe1xuICAgICAgY29uZmlndXJhdGlvbixcbiAgICAgIGVtYmVkZGluZ0Z1bmN0aW9uXG4gICAgfSk7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5jcmVhdGVDb2xsZWN0aW9uKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiBhd2FpdCB0aGlzLl9wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IGNvbGxlY3Rpb25Db25maWcsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBnZXRfb3JfY3JlYXRlOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbkltcGwoe1xuICAgICAgY2hyb21hQ2xpZW50OiB0aGlzLFxuICAgICAgYXBpQ2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIG5hbWUsXG4gICAgICBjb25maWd1cmF0aW9uOiBkYXRhLmNvbmZpZ3VyYXRpb25fanNvbixcbiAgICAgIG1ldGFkYXRhLFxuICAgICAgZW1iZWRkaW5nRnVuY3Rpb246IGVtYmVkZGluZ0Z1bmN0aW9uID8/IGF3YWl0IGdldEVtYmVkZGluZ0Z1bmN0aW9uKFxuICAgICAgICBkYXRhLm5hbWUsXG4gICAgICAgIGRhdGEuY29uZmlndXJhdGlvbl9qc29uLmVtYmVkZGluZ19mdW5jdGlvbiA/PyB2b2lkIDBcbiAgICAgICksXG4gICAgICBpZDogZGF0YS5pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYW4gZXhpc3RpbmcgY29sbGVjdGlvbiBieSBuYW1lLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbGxlY3Rpb24gcmV0cmlldmFsIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb2xsZWN0aW9uIHRvIHJldHJpZXZlXG4gICAqIEBwYXJhbSBvcHRpb25zLmVtYmVkZGluZ0Z1bmN0aW9uIC0gT3B0aW9uYWwgZW1iZWRkaW5nIGZ1bmN0aW9uLiBTaG91bGQgbWF0Y2ggdGhlIG9uZSB1c2VkIHRvIGNyZWF0ZSB0aGUgY29sbGVjdGlvbi5cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIENvbGxlY3Rpb24gaW5zdGFuY2VcbiAgICogQHRocm93cyBFcnJvciBpZiB0aGUgY29sbGVjdGlvbiBkb2VzIG5vdCBleGlzdFxuICAgKi9cbiAgYXN5bmMgZ2V0Q29sbGVjdGlvbih7XG4gICAgbmFtZSxcbiAgICBlbWJlZGRpbmdGdW5jdGlvblxuICB9KSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5nZXRDb2xsZWN0aW9uKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiB7IC4uLmF3YWl0IHRoaXMuX3BhdGgoKSwgY29sbGVjdGlvbl9pZDogbmFtZSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uSW1wbCh7XG4gICAgICBjaHJvbWFDbGllbnQ6IHRoaXMsXG4gICAgICBhcGlDbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgbmFtZSxcbiAgICAgIGNvbmZpZ3VyYXRpb246IGRhdGEuY29uZmlndXJhdGlvbl9qc29uLFxuICAgICAgbWV0YWRhdGE6IGRhdGEubWV0YWRhdGEgPz8gdm9pZCAwLFxuICAgICAgZW1iZWRkaW5nRnVuY3Rpb246IGVtYmVkZGluZ0Z1bmN0aW9uID8gZW1iZWRkaW5nRnVuY3Rpb24gOiBhd2FpdCBnZXRFbWJlZGRpbmdGdW5jdGlvbihcbiAgICAgICAgZGF0YS5uYW1lLFxuICAgICAgICBkYXRhLmNvbmZpZ3VyYXRpb25fanNvbi5lbWJlZGRpbmdfZnVuY3Rpb24gPz8gdm9pZCAwXG4gICAgICApLFxuICAgICAgaWQ6IGRhdGEuaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIG11bHRpcGxlIGNvbGxlY3Rpb25zIGJ5IG5hbWUuXG4gICAqIEBwYXJhbSBpdGVtcyAtIEFycmF5IG9mIGNvbGxlY3Rpb24gbmFtZXMgb3Igb2JqZWN0cyB3aXRoIG5hbWUgYW5kIG9wdGlvbmFsIGVtYmVkZGluZyBmdW5jdGlvbiAoc2hvdWxkIG1hdGNoIHRoZSBvbmVzIHVzZWQgdG8gY3JlYXRlIHRoZSBjb2xsZWN0aW9ucylcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgQ29sbGVjdGlvbiBpbnN0YW5jZXNcbiAgICovXG4gIGFzeW5jIGdldENvbGxlY3Rpb25zKGl0ZW1zKSB7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGxldCByZXF1ZXN0ZWRDb2xsZWN0aW9ucyA9IGl0ZW1zO1xuICAgIGlmICh0eXBlb2YgaXRlbXNbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlcXVlc3RlZENvbGxlY3Rpb25zID0gaXRlbXMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IGl0ZW0sIGVtYmVkZGluZ0Z1bmN0aW9uOiB2b2lkIDAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgY29sbGVjdGlvbnMgPSByZXF1ZXN0ZWRDb2xsZWN0aW9ucztcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBjb2xsZWN0aW9ucy5tYXAoYXN5bmMgKGNvbGxlY3Rpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sbGVjdGlvbih7IC4uLmNvbGxlY3Rpb24gfSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYW4gZXhpc3RpbmcgY29sbGVjdGlvbiBvciBjcmVhdGVzIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29sbGVjdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWd1cmF0aW9uIC0gT3B0aW9uYWwgY29sbGVjdGlvbiBjb25maWd1cmF0aW9uICh1c2VkIG9ubHkgaWYgY3JlYXRpbmcpXG4gICAqIEBwYXJhbSBvcHRpb25zLm1ldGFkYXRhIC0gT3B0aW9uYWwgbWV0YWRhdGEgZm9yIHRoZSBjb2xsZWN0aW9uICh1c2VkIG9ubHkgaWYgY3JlYXRpbmcpXG4gICAqIEBwYXJhbSBvcHRpb25zLmVtYmVkZGluZ0Z1bmN0aW9uIC0gT3B0aW9uYWwgZW1iZWRkaW5nIGZ1bmN0aW9uIHRvIHVzZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgQ29sbGVjdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgYXN5bmMgZ2V0T3JDcmVhdGVDb2xsZWN0aW9uKHtcbiAgICBuYW1lLFxuICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgbWV0YWRhdGEsXG4gICAgZW1iZWRkaW5nRnVuY3Rpb25cbiAgfSkge1xuICAgIGNvbnN0IGNvbGxlY3Rpb25Db25maWcgPSBhd2FpdCBwcm9jZXNzQ3JlYXRlQ29sbGVjdGlvbkNvbmZpZyh7XG4gICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgZW1iZWRkaW5nRnVuY3Rpb25cbiAgICB9KTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNyZWF0ZUNvbGxlY3Rpb24oe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMuX3BhdGgoKSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY29uZmlndXJhdGlvbjogY29sbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGdldF9vcl9jcmVhdGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25JbXBsKHtcbiAgICAgIGNocm9tYUNsaWVudDogdGhpcyxcbiAgICAgIGFwaUNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBuYW1lLFxuICAgICAgY29uZmlndXJhdGlvbjogZGF0YS5jb25maWd1cmF0aW9uX2pzb24sXG4gICAgICBtZXRhZGF0YTogZGF0YS5tZXRhZGF0YSA/PyB2b2lkIDAsXG4gICAgICBlbWJlZGRpbmdGdW5jdGlvbjogZW1iZWRkaW5nRnVuY3Rpb24gPz8gYXdhaXQgZ2V0RW1iZWRkaW5nRnVuY3Rpb24oXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRhdGEuY29uZmlndXJhdGlvbl9qc29uLmVtYmVkZGluZ19mdW5jdGlvbiA/PyB2b2lkIDBcbiAgICAgICksXG4gICAgICBpZDogZGF0YS5pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgY29sbGVjdGlvbiBhbmQgYWxsIGl0cyBkYXRhLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIERlbGV0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb2xsZWN0aW9uIHRvIGRlbGV0ZVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlQ29sbGVjdGlvbih7IG5hbWUgfSkge1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLmRlbGV0ZUNvbGxlY3Rpb24oe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IHsgLi4uYXdhaXQgdGhpcy5fcGF0aCgpLCBjb2xsZWN0aW9uX2lkOiBuYW1lIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBlbnRpcmUgZGF0YWJhc2UsIGRlbGV0aW5nIGFsbCBjb2xsZWN0aW9ucyBhbmQgZGF0YS5cbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHJlc2V0IGlzIGNvbXBsZXRlXG4gICAqIEB3YXJuaW5nIFRoaXMgb3BlcmF0aW9uIGlzIGlycmV2ZXJzaWJsZSBhbmQgd2lsbCBkZWxldGUgYWxsIGRhdGFcbiAgICovXG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLnJlc2V0KHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdmVyc2lvbiBvZiB0aGUgQ2hyb21hIHNlcnZlci5cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHNlcnZlciB2ZXJzaW9uIHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgdmVyc2lvbigpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLnZlcnNpb24oe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwcmVmbGlnaHQgY2hlY2tzXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBwcmVmbGlnaHQgY2hlY2tzXG4gICAqL1xuICBhc3luYyBnZXRQcmVmbGlnaHRDaGVja3MoKSB7XG4gICAgaWYgKCF0aGlzLnByZWZsaWdodENoZWNrcykge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5wcmVGbGlnaHRDaGVja3Moe1xuICAgICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJlZmxpZ2h0Q2hlY2tzID0gZGF0YTtcbiAgICAgIHJldHVybiB0aGlzLnByZWZsaWdodENoZWNrcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJlZmxpZ2h0Q2hlY2tzO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtYXggYmF0Y2ggc2l6ZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgbWF4IGJhdGNoIHNpemVcbiAgICovXG4gIGFzeW5jIGdldE1heEJhdGNoU2l6ZSgpIHtcbiAgICBjb25zdCBwcmVmbGlnaHRDaGVja3MgPSBhd2FpdCB0aGlzLmdldFByZWZsaWdodENoZWNrcygpO1xuICAgIHJldHVybiBwcmVmbGlnaHRDaGVja3MubWF4X2JhdGNoX3NpemUgPz8gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBiYXNlNjRfZW5jb2RpbmcgaXMgc3VwcG9ydGVkIGJ5IHRoZSBjb25uZWN0ZWQgc2VydmVyXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHdoZXRoZXIgYmFzZTY0X2VuY29kaW5nIGlzIHN1cHBvcnRlZFxuICAgKi9cbiAgYXN5bmMgc3VwcG9ydHNCYXNlNjRFbmNvZGluZygpIHtcbiAgICBjb25zdCBwcmVmbGlnaHRDaGVja3MgPSBhd2FpdCB0aGlzLmdldFByZWZsaWdodENoZWNrcygpO1xuICAgIHJldHVybiBwcmVmbGlnaHRDaGVja3Muc3VwcG9ydHNfYmFzZTY0X2VuY29kaW5nID8/IGZhbHNlO1xuICB9XG59O1xuXG4vLyBzcmMvY2xvdWQtY2xpZW50LnRzXG5pbXBvcnQgKiBhcyBwcm9jZXNzMiBmcm9tIFwibm9kZTpwcm9jZXNzXCI7XG52YXIgQ2xvdWRDbGllbnQgPSBjbGFzcyBleHRlbmRzIENocm9tYUNsaWVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENsb3VkQ2xpZW50IGluc3RhbmNlIGZvciBDaHJvbWEgQ2xvdWQuXG4gICAqIEBwYXJhbSBhcmdzIC0gQ2xvdWQgY2xpZW50IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncyA9IHt9KSB7XG4gICAgY29uc3QgYXBpS2V5ID0gYXJncy5hcGlLZXkgfHwgcHJvY2VzczIuZW52LkNIUk9NQV9BUElfS0VZO1xuICAgIGlmICghYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgXCJNaXNzaW5nIEFQSSBrZXkuIFBsZWFzZSBwcm92aWRlIGl0IHRvIHRoZSBDbG91ZENsaWVudCBjb25zdHJ1Y3RvciBvciBzZXQgeW91ciBDSFJPTUFfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZVwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB0ZW5hbnQgPSBhcmdzLnRlbmFudCB8fCBwcm9jZXNzMi5lbnYuQ0hST01BX1RFTkFOVDtcbiAgICBjb25zdCBkYXRhYmFzZSA9IGFyZ3MuZGF0YWJhc2UgfHwgcHJvY2VzczIuZW52LkNIUk9NQV9EQVRBQkFTRTtcbiAgICBzdXBlcih7XG4gICAgICBob3N0OiBcImFwaS50cnljaHJvbWEuY29tXCIsXG4gICAgICBwb3J0OiA4ZTMsXG4gICAgICBzc2w6IHRydWUsXG4gICAgICB0ZW5hbnQsXG4gICAgICBkYXRhYmFzZSxcbiAgICAgIGhlYWRlcnM6IHsgXCJ4LWNocm9tYS10b2tlblwiOiBhcGlLZXkgfSxcbiAgICAgIGZldGNoT3B0aW9uczogYXJncy5mZXRjaE9wdGlvbnNcbiAgICB9KTtcbiAgICB0aGlzLnRlbmFudCA9IHRlbmFudDtcbiAgICB0aGlzLmRhdGFiYXNlID0gZGF0YWJhc2U7XG4gIH1cbn07XG52YXIgQWRtaW5DbG91ZENsaWVudCA9IGNsYXNzIGV4dGVuZHMgQWRtaW5DbGllbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBBZG1pbkNsb3VkQ2xpZW50IGluc3RhbmNlIGZvciBjbG91ZCBhZG1pbiBvcGVyYXRpb25zLlxuICAgKiBAcGFyYW0gYXJncyAtIEFkbWluIGNsb3VkIGNsaWVudCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IGFwaUtleSA9IGFyZ3MuYXBpS2V5IHx8IHByb2Nlc3MyLmVudi5DSFJPTUFfQVBJX0tFWTtcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIFwiTWlzc2luZyBBUEkga2V5LiBQbGVhc2UgcHJvdmlkZSBpdCB0byB0aGUgQ2xvdWRDbGllbnQgY29uc3RydWN0b3Igb3Igc2V0IHlvdXIgQ0hST01BX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgc3VwZXIoe1xuICAgICAgaG9zdDogXCJhcGkudHJ5Y2hyb21hLmNvbVwiLFxuICAgICAgcG9ydDogOGUzLFxuICAgICAgc3NsOiB0cnVlLFxuICAgICAgaGVhZGVyczogeyBcIngtY2hyb21hLXRva2VuXCI6IGFwaUtleSB9LFxuICAgICAgZmV0Y2hPcHRpb25zOiBhcmdzLmZldGNoT3B0aW9uc1xuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQWRtaW5DbGllbnQsXG4gIEFkbWluQ2xvdWRDbGllbnQsXG4gIENocm9tYUNsaWVudCxcbiAgQ2hyb21hQ2xpZW50RXJyb3IsXG4gIENocm9tYUNvbm5lY3Rpb25FcnJvcixcbiAgQ2hyb21hRXJyb3IsXG4gIENocm9tYUZvcmJpZGRlbkVycm9yLFxuICBDaHJvbWFOb3RGb3VuZEVycm9yLFxuICBDaHJvbWFRdW90YUV4Y2VlZGVkRXJyb3IsXG4gIENocm9tYVJhdGVMaW1pdEVycm9yLFxuICBDaHJvbWFTZXJ2ZXJFcnJvcixcbiAgQ2hyb21hVW5hdXRob3JpemVkRXJyb3IsXG4gIENocm9tYVVuaXF1ZUVycm9yLFxuICBDaHJvbWFWYWx1ZUVycm9yLFxuICBDbG91ZENsaWVudCxcbiAgR2V0UmVzdWx0LFxuICBJbmNsdWRlRW51bSxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRDb2xsZWN0aW9uRXJyb3IsXG4gIFF1ZXJ5UmVzdWx0LFxuICBiYXNlUmVjb3JkU2V0RmllbGRzLFxuICBjcmVhdGVFcnJvckJ5VHlwZSxcbiAgZ2V0RGVmYXVsdEVGQ29uZmlnLFxuICBnZXRFbWJlZGRpbmdGdW5jdGlvbixcbiAga25vd25FbWJlZGRpbmdGdW5jdGlvbnMsXG4gIHByb2Nlc3NDcmVhdGVDb2xsZWN0aW9uQ29uZmlnLFxuICBwcm9jZXNzVXBkYXRlQ29sbGVjdGlvbkNvbmZpZyxcbiAgcmVjb3JkU2V0RmllbGRzLFxuICByZWdpc3RlckVtYmVkZGluZ0Z1bmN0aW9uLFxuICBzZXJpYWxpemVFbWJlZGRpbmdGdW5jdGlvbixcbiAgd2l0aENocm9tYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNocm9tYWRiLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/chromadb/dist/chromadb.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __publicField: () => (/* binding */ __publicField)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n//# sourceMappingURL=chunk-NSSMTXJJ.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hyb21hZGIvZGlzdC9jaHVuay1OU1NNVFhKSi5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTs7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29uc3RpdHV0aW9uLy4vbm9kZV9tb2R1bGVzL2Nocm9tYWRiL2Rpc3QvY2h1bmstTlNTTVRYSkoubWpzP2JmNzIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcblxuZXhwb3J0IHtcbiAgX19wdWJsaWNGaWVsZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLU5TU01UWEpKLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs\n");

/***/ })

};
;